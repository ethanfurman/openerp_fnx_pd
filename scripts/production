#!/usr/bin/env python

from math import ceil
from scription import Script, Command, Run, mail
from syslog import syslog
from VSS import Date, fix_date
from VSS.openerp import get_records
from VSS.path import Path, listdir, glob
from VSS.time_machine import PropertyDict
from VSS.utils import ProgressBar, Enum, IntEnum, AutoEnum, IndexEnum, Weekday
from VSS.xl import open_workbook
import openerplib
import shutil
import time

SOURCE = Path('/var/fis/production/')
ARCHIVE = Path('/var/openerp/archive/production/')
ERRORS = Path('/var/openerp/archive/production/error')
USER_PW_DB = Path('/etc/openerp/credentials')

execfile(USER_PW_DB)

module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

ProductionState = IntEnum(
    'ProductionState',
    'draft needy partial scheduled ready running complete cancelled',
    )
globals().update(ProductionState.__members__)

QAll_C = IndexEnum(
    'QAll_C',
    zip("header email dept prod_line type item_code item_desc order_num confirmed qty date day coating allergens".split(), range(100)),
    )
globals().update(QAll_C.__members__)

class BadFormat(Exception):
    "production order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = glob(dest/basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def connect(hostname, database, user, password):
    OE = PropertyDict()
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    return OE

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    return PropertyDict(g['order'])

def import_spreadsheet(OE, file_name):
    errors = []
    imported_orders = []   # list of imported current orders so that non-current orders still on file can be flagged completed
    line_ids = PropertyDict((r.xml_id, r) for r in get_records(OE, 'fis_integration.production_line', fields=['id','xml_id']))
    with open_workbook(file_name) as work_book:
        sheet = work_book[2]
        last_row = None
        for row in sheet.rows(start_row=1):
            if row == last_row:
                continue
            followers = get_records(OE, 'res.users', fields=['id'], domain=[('login','=',row[email])], max_qty=1)
            followers = [rec.id for rec in followers] or False
            item = get_records(OE, 'product.product', fields=['id'], domain=[('xml_id','=',row[item_code])], max_qty=1)
            if not item:
                # couldn't find the product, record the error
                errors.append('order %s: product %s not found' % (row[order_num], row[item_code]))
                continue
            item = item[0].id
            data = PropertyDict()
            data.follower_ids = followers
            data.dept = row[dept]
            # the value of row[prod_line] should be the textual representation of an integer between '01' and '99'
            prod_id = '%02d' % int(row[prod_line])
            data.line_id = line_ids[prod_id].id
            data.item_id = item
            data.order_no = row[order_num]
            data.confirmed = row[confirmed] == 'Y'
            data.qty = int(ceil(float(row[qty])))
            sched_date = fix_date(row[date], format='ymd')
            if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                continue
            imported_orders.append(data.order_no)
            data.date = str(sched_date)
            data.coating = row[coating]
            data.allergens = row[allergens]
            current_record = get_records(OE, 'fnx.pd.order', domain=[('order_no','=',data.order_no)], max_qty=1)
            if current_record:
                current_record = current_record[0]
                if row[prod_line] == '98':
                    del data.line_id
                OE.fnx_pd_order.write(current_record.id, dict(data))
            else:
                OE.fnx_pd_order.create(dict(data))
    oe_open_orders = [o.id for o in get_records(
            OE,
            'fnx.pd.order',
            fields=['id'],
            domain=[('order_no','not in',imported_orders),('state','not in',['closed','cancelled'])],
            )]
    if oe_open_orders:
        OE.fnx_pd_order.pd_update_state(oe_open_orders, context={'dropped':True})
    return errors


def update_order(values):
    pass


@Command(
        values=('settings to use', 'keyword', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def manual_update(hostname='localhost', db=DB, login=USER, password=None, **values):
    if password is None:
        password = PW
    OE = connect(hostname, db, login, password)
    pass

@Command(
        file_to_process=('order to add/update in system', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def process(file_to_process='', hostname='localhost', db=DB, login=USER, password=None):
    "imports a production spreadsheet into FnxPd"
    if password is None:
        password = PW
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    OE = connect(hostname, db, login, password)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    retry = []
    failed = []
    for group in ((files, failed), ):
        time.sleep(5)
        trying, failing = group
        for file in trying:
            errors = import_spreadsheet(OE, file)
            if errors:
                raise ValueError("Unable to process orders:\n\t%s" % '\n\t'.join(errors))
            #archive(file, dest)
    if failed:
        raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))

if __name__ == '__main__':
    Run()

