#!/usr/bin/env python
# imports
from __future__ import print_function

from antipathy import Path
import sys
sys.path.insert(0, Path(__file__).path * Path('../../fis_integration/scripts'))

import email
import shutil
import time
from openerplib import AttrDict, get_connection, get_records
from constants import *
from scription import *
from VSS.constants import Weekday
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_date, Date
from VSS.xl import open_workbook
from recipe import get_fis_data, get_ingredients, F320, F322, F323


SOURCE = Path('/var/fis/production/')
ARCHIVE = Path('/var/openerp/archive/production/')
ERRORS = Path('/var/openerp/archive/production/error')
USER_PW_DB = Path('/etc/openerp/credentials')

# dummy values to be filled in by USER_PW_DB

DB = USER = PW = None
execfile(USER_PW_DB)

# API

@Command(
        values=('settings to use', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def manual_update(hostname='localhost', db=DB, login=USER, password=None, **values):
    if password is None:
        password = PW
    OE = connect(hostname, db, login, password)
    OE
    pass

@Command(
        file_to_process=('order to add/update in system', ),
        order=('specific order number from file to process', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def process(file_to_process='', order='', hostname='localhost', db=DB, login=USER, password=None):
    "imports a production spreadsheet into FnxPd"
    if password is None:
        password = PW
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    OE = connect(hostname, db, login, password)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    OE.fnx_pd_ingredient = OE.conn.get_model('fnx.pd.ingredient')
    OE.product = OE.conn.get_model('product.product')
    OE.inventory = AttrDict()
    failed = []
    for group in ((files, failed), ):
        time.sleep(5)
        trying, failing = group
        for file in trying:
            print('using file:', file)
            errors = import_spreadsheet(OE, file, order or None)
            if errors:
                # print to stdout
                print('-------', file=stderr)
                for err in errors:
                    print(err, file=stderr)
                if db.startswith('test'):
                    # do not send mail from test machines
                    abort('errors during processing')
                [fnxpd_manager] = get_records(OE.conn, 'ir.model.data', domain=[('module','=','fnx_pd'),('model','=','res.groups'),('name','=','group_fnx_pd_manager')])
                [fnxpd_manager_group] = get_records(OE.conn, 'res.groups', domain=[('id','=',fnxpd_manager.res_id)])
                managers = get_records(OE.conn, 'res.users', domain=[('id','in',fnxpd_manager_group.users)], fields=['id','login','email'])
                emails = [mgr.email for mgr in managers if mgr.id != 1 and mgr.email]
                if emails:
                    print('-------', file=stderr)
                    print('sending to: ', ', '.join(emails), file=stderr)
                    mail_errors = mail(
                        'mail.sunridgefarms.com',
                        25,
                        process_failure_mail % (
                            ', '.join(emails),
                            email.utils.formatdate(email.utils.mktime_tz(time.localtime()+(None,))),
                            '\n'.join(errors),
                            )
                        )
                    if mail_errors:
                        print('unable to mail: ', mail_errors.items(), sep='\n   ', file=stderr)
                    raise SystemExit("errors during processing, mail attempted")
                else:
                    raise SystemExit("errors during processing")
    if failed:
        raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))

# helpers

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def connect(hostname, database, user, password):
    OE = AttrDict()
    print('connecting to %s:%s' % (hostname, database))
    OE.conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    return OE

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    return AttrDict(g['order'])

def import_spreadsheet(OE, file_name, only_order_no):
    '''
    add/update orders from spreadsheet; also add as-yet-unreferenced formulai
    '''
    # production date, production line should not be updated from QALL once they have been changed in OpenERP
    global fis_f320, fis_f328
    get_fis_data()
    fis_f320 = fisData(320, keymatch='10%s  %s0')
    fis_f328 = fisData(328, keymatch='10%s000010000')
    errors = []
    # list of imported current orders so that non-current orders still on file can be flagged completed/cancelled
    imported_orders = []
    # completed_orders = []   # list of orders that are marked completed in FIS
    line_ids = dict(
            (r.xml_id, r) for r in get_records(
                OE.conn,
                'fis_integration.production_line',
                fields=['id','xml_id'],
            ))
    today = Date.today()
    # get current orders and construct a dict of (schedule_date, min(sequence))
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        last_row = None
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            if row == last_row:
                continue
            data = AttrDict()
            order_num = row[ORDER_NUM]
            if only_order_no and order_num != only_order_no:
                continue
            print('processing row %d, order %s' % (i, order_num), verbose=2)
            item = get_records(OE.conn, 'product.product', fields=['id'], domain=[('xml_id','=',row[ITEM_CODE])], max_qty=1)
            if not item:
                # couldn't find the product, record the error
                errors.append('<row %3d> order %s: product %s not found' % (i, order_num, row[ITEM_CODE]))
                print(errors[-1])
                continue
            try:
                fis_row = fis_f328[order_num]
            except KeyError:
                errors.append('  cannot find %s in FIS' % order_num)
                print(errors[-1])
                continue
            item = item[0].id
            # pad the formula to 10 chars
            formula_id_rev = '%-10s' % fis_row[F328.formula_id], fis_row[F328.formula_rev]
            data.dept = fis_row[F328.dept_id]
            # the value of fis_row[F328.prod_line] should be the textual representation of an integer between '01' and '99'
            try:
                prodline_id = '%02d' % int(fis_row[F328.prod_line])
            except ValueError:
                # no product line, record the error
                errors.append('<row %3d> order %s: no product line (using 98)' % (i, order_num))
                print(errors[-1])
                prodline_id = '98'
            if prodline_id not in line_ids:
                errors.append('<row %3d> order %s: line_id %s does not exist (using 98)' % (i, order_num, prodline_id))
                print(errors[-1])
                prodline_id = '98'
            data.line_id = line_ids[prodline_id].id
            data.item_id = item
            data.order_no = order_num
            data.confirmed = (False, 'fis')[fis_row[F328.order_confirmed] == 'Y']
            data.ordered_qty = fis_row[F328.qty_on_order]
            try:
                sched_date = fix_date(row[DATE], format='ymd')
            except ValueError:
                sched_date = ''
            if not sched_date:
                # no schedule date, record the error
                errors.append('<row %3d> order %s: missing or invalid schedule date' % (i, order_num))
                print(errors[-1])
                data.schedule_date = False
            else:
                data.schedule_date = str(sched_date)
            data.completed_fis_qty = fis_row[F328.units_produced] or False
            if data.completed_fis_qty:
                data.finish_date = str(fix_date(fis_row[F328.prod_date], format='mdy')) or False
                if data.finish_date:
                    data.finish_date += " 00:00:00"
            else:
                data.finish_date = False
            imported_orders.append(data.order_no)
            current_records = get_records(OE.conn, 'fnx.pd.order', domain=[('order_no','=',data.order_no)], max_qty=1)
            if current_records:
                print('  checking for changed fields', verbose=2)
                del data.dept
                del data.order_no
                current_record = current_records[0]
                if not current_record.ingredient_ids:
                    update_formula(OE, formula_id_rev, data, errors)
                for k in data.keys():
                    if k.endswith('_id'):
                        if data[k] == current_record[k][0]:
                            del data[k]
                    elif data[k] == current_record[k]:
                        del data[k]
                if data:
                    if sched_date:
                        if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                            print('deleting %s: Saturday schedule' % order_num)
                            OE.fnx_pd_order.unlink(current_record.id, context={'script': True})
                            continue
                        elif (sched_date - today).days > 21:
                            print('deleting %s: more than three weeks out' % order_num)
                            OE.fnx_pd_order.unlink(current_record.id, context={'script': True})
                            continue
                    print('updating %s' % row[ORDER_NUM])
                    for key in data:
                        if data[key] != current_record[key]:
                            print('  %s: %r -> %r' % (key, current_record[key], data[key]))
                        else:
                            print('  oops, forgot to delete key', key)
                    OE.fnx_pd_order.write(current_record.id, dict(data), context={'script': True})
            elif sched_date and Weekday.from_date(sched_date) is Weekday.SATURDAY:
                print('skipping %s: Saturday schedule' % order_num)
                continue
            else:
                update_formula(OE, formula_id_rev, data, errors)
                print('creating %s' % row[ORDER_NUM], 'with:\n', data)
                OE.fnx_pd_order.create(dict(data), context={'script': True})
    if only_order_no:
        return errors
    oe_open_orders = get_records(
            OE.conn,
            'fnx.pd.order',
            fields=['id', 'completed_fis_qty', 'order_no', 'schedule_date', 'state'],
            domain=[('state','not in',['complete','cancelled'])],
            )
    print('OE open orders: ', len(oe_open_orders))
    for open_order in oe_open_orders:
        data = AttrDict()
        print('checking open order %s' % open_order.order_no)
        try:
            fis_row = fis_f328[open_order.order_no]
        except KeyError:
            # no longer present, delete
            print('deleting missing order: %s' % open_order.order_no)
            OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
            continue
        else:
            status = fis_row[F328.produced]
            sched_date = fix_date(fis_row[F328.prod_sched_date], format='ymd') or False
            if sched_date:
                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                    print('deleting %s: Saturday schedule' % open_order.order_no)
                    OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                elif (sched_date - today).days > 21:
                    print('deleting %s: more than three weeks out' % open_order.order_no)
                    OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                data.schedule_date = str(sched_date)
            print('  using %r' % sched_date)
            # if not open_order.schedule_date:
            #     print('  schedule date missing')
            finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
            if finish_date:
                data.finish_date = str(finish_date)
            qty = fis_row[F328.units_produced] or False
            if qty and qty != open_order.completed_fis_qty:
                data.completed_fis_qty = fis_row[F328.units_produced]
        if status == 'Y':
            state = 'complete'
        elif status == 'X':
            state = 'cancelled'
        elif status in 'P N':
            state = None
        else:
            # unknown, skip until tomorrow and hope somebody fixes it
            print('order %s: unknown status %r' % (open_order.order_no, fis_row[F328.produced]))
            state = None
        if state and state != open_order.state:
            data.state = state
        if data:
            print('updating %s: %s' % (open_order.order_no, dict(data)))
            OE.fnx_pd_order.write([open_order.id], dict(data), context={'script': True})
    return errors

def update_formula(OE, id_rev, data, errors):
    from recipe import IFDT1_REV
    formula = fis_f320[id_rev]
    target_item = id_rev[0][:6]
    # create the individual ingredients
    ingreds = get_ingredients(*id_rev, food_only=True)
    ingreds_ids = []
    if IFDT1_REV.has_key(id_rev):
        yield_qty = IFDT1_REV[id_rev][F323.yield_in_units]
        scale = data.ordered_qty / yield_qty
    else:
        errors.append('unable to find yield qty for %s-%s' % id_rev)
        yield_qty = 0.0
        scale = 0.0
    discard = False  # in case ingreds is empty
    for item_id, key, ingredient, _ in ingreds:
        if item_id == target_item:
            continue
        discard = False
        item_xml_id = ingredient[F322.ingr_id_batch_1]
        qty_needed = ingredient[F322.qty_batch_1] * scale
        qty_desc = ingredient[F322.desc_batch_1][-8:]
        item_id = OE.inventory.get(item_xml_id)
        if item_id is None:
            try:
                item_id = OE.product.search([('xml_id','=',item_xml_id)])[0]
            except IndexError:
                discard = True
                errors.append('unable to find ingredient %r in formula %s' % (item_xml_id, id_rev))
                OE.fnx_pd_ingredient.unlink(ingreds_ids)
                ingreds_ids = []
                break
        ingreds_ids.append(OE.fnx_pd_ingredient.create({
                'item_id':item_id,
                'qty_needed':qty_needed,
                'qty_desc':' '.join(qty_desc.split()),
                }))
    if discard or not yield_qty:
        OE.fnx_pd_ingredient.unlink(ingreds_ids)
        ingreds_ids = []
    elif ingreds_ids:
        data.ingredient_ids = [(6, 0, ingreds_ids)]
    # add the formula details
    data.formula_code ='%s [%s-%s]' % (formula[F320.desc], id_rev[0].strip(), id_rev[1])
    data.coating = formula[F320.coating]
    data.allergens = formula[F320.allergens]

def update_order(values):
    pass


Main()
