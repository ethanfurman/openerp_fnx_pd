#!/usr/local/sbin/suid-python --virtualenv
# imports
from __future__ import print_function

from antipathy import Path
import sys
sys.path.insert(0, Path(__file__).path * Path('../../fis_integration/scripts'))

import email
import os
import shutil
import time
from dbf import Date, Time, DateTime
from openerplib import AttrDict, get_connection, get_records
from openerplib.dates import LOCAL_TIME, date_to_str, datetime_to_str
from constants import *
from scription import *
from VSS.constants import Weekday
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_date
from VSS.xl import open_workbook
from recipe import get_fis_data, get_order_ingredients, F320, F329
from traceback import format_exception
from xmlrpclib import Fault

VIRTUAL_ENV = os.environ['VIRTUAL_ENV']
SOURCE = Path('%s/var/fis/production/' % VIRTUAL_ENV)
ARCHIVE = Path('%s/var/openerp/archive/production/' % VIRTUAL_ENV)
ERRORS = Path('%s/var/openerp/archive/production/error' % VIRTUAL_ENV)
CONFIG = OrmFile('%s/config/fnx.ini' % VIRTUAL_ENV, section='openerp')


# API

@Command(
        table=Spec('which table to update', REQUIRED, choices=['product','production']),
        ids=Spec('ids of records to change', REQUIRED),
        values=Spec('settings to use', REQUIRED),
        )
def manual_update(table, ids, **values):
    OE = connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    ids = [int(i) for i in ids.replace(',',' ').split()]
    for key, value in values.items():
        for t in (int, float):
            try:
                value = t(value)
                break
            except ValueError:
                pass
    table = OE.conn.get_model({'product':'product.product', 'production':'fnx_pd.production'}[table])
    table.write(ids, values)

@Command(
        file_to_process=('order to add/update in system', ),
        order=('specific order number from file to process', ),
        dryrun=('do not update tables', FLAG),
        )
def process(file_to_process='', order='', dryrun=False):
    "imports a production spreadsheet into FnxPd"
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    OE = connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    OE.fnx_pd_ingredient = OE.conn.get_model('fnx.pd.ingredient')
    OE.product = OE.conn.get_model('product.product')
    OE.inventory = dict([
        (r.xml_id, r.id)
        for r in get_records(
                OE.conn,
                'product.product',
                fields=['id', 'xml_id'],
                domain=[('module','=','F135')],
                )])
    failed = []
    for group in ((files, failed), ):
        time.sleep(5)
        trying, failing = group
        for file in trying:
            print('using file:', file)
            imported_orders, errors = import_spreadsheet(OE, file, order or None, dryrun=dryrun)
            check_open_orders(OE, dryrun=dryrun)
            if errors:
                if CONFIG.db.startswith('test') or dryrun:
                    # do not send mail from test machines nor during dry runs
                    abort('errors during processing')
                [fnxpd_manager] = get_records(
                        OE.conn,
                        'ir.model.data',
                        domain=[('module','=','fnx_pd'),('model','=','res.groups'),('name','=','group_fnx_pd_manager')],
                        )
                [fnxpd_manager_group] = get_records(
                        OE.conn,
                        'res.groups',
                        domain=[('id','=',fnxpd_manager.res_id)],
                        )
                managers = get_records(
                        OE.conn,
                        'res.users',
                        domain=[('id','in',fnxpd_manager_group.users)],
                        fields=['id','login','email'],
                        )
                emails = [mgr.email for mgr in managers if mgr.id != 1 and mgr.email]
                if emails:
                    print('-------', file=stderr)
                    print('sending to: ', ', '.join(emails), file=stderr)
                    mail_errors = mail(
                        'mail.sunridgefarms.com',
                        25,
                        process_failure_mail % (
                            ', '.join(emails),
                            email.utils.formatdate(email.utils.mktime_tz(time.localtime()+(None,))),
                            '\n'.join(errors),
                            )
                        )
                    if mail_errors:
                        print('unable to mail: ', mail_errors.items(), sep='\n   ', file=stderr)
                    raise SystemExit("errors during processing, mail attempted")
                else:
                    raise SystemExit("errors during processing")
    if failed:
        raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))

@Command(
        dryrun=('do not update tables', FLAG),
        )
def open_orders(dryrun=False):
    "check open orders and close if necessary"
    OE = connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    check_open_orders(OE, dryrun=dryrun)

# helpers

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def connect(hostname, database, user, password):
    OE = AttrDict()
    print('connecting to %s:%s' % (hostname, database))
    OE.conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    return OE

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    return AttrDict(g['order'])

def import_spreadsheet(OE, file_name, only_order_no, dryrun):
    '''
    add/update orders from spreadsheet; also add as-yet-unreferenced formulai
    '''
    # production date, production line should not be updated from QALL once
    # they have been changed in OpenERP
    global fis_f320, fis_f328, order_ids
    get_fis_data()
    fis_f320 = fisData(320, keymatch='10%s  %s0')
    fis_f328 = fisData(328, keymatch='10%s000010000')
    errors = []
    # list of imported current orders so that non-current orders still on file
    # can be flagged completed/cancelled
    imported_orders = []
    line_ids = dict(
            (r.xml_id, r) for r in get_records(
                OE.conn,
                'fis_integration.production_line',
                fields=['id','xml_id'],
            ))
    order_ids = dict(
            (r.order_no, r) for r in get_records(
                OE.conn,
                'fnx.pd.order',
                fields=['id', 'order_no'],
                ))
    today = Date.today()
    # get current orders and construct a dict of (schedule_date, min(sequence))
    multilines = dict([(r.key, r.line_ids) for r in get_records(OE.conn, 'fnx.pd.multiline', fields=['key', 'line_ids'])])
    multistep = {}
    for key, multiline in multilines.items():
        lines = get_records(OE.conn, 'fnx.pd.multiline.entry', ids=multiline, fields=['line_id'])
        ids = [l.line_id[0] for l in lines]
        sequence = [(i, l.line_id[0]) for i, l in enumerate(lines)]
        xml_ids_map = dict([(x.id, x) for x in get_records(OE.conn, 'fis_integration.production_line', ids=ids, fields=['xml_id'])])
        xml_ids = []
        for seq, xid in sequence:
            xml_ids.append(xml_ids_map[xid])
        multistep[key] = [r.xml_id for r in xml_ids]
    for key, lines in multistep.items():
        print(key, lines, verbose=2)
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        last_row = None
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            try:
                if row == last_row:
                    continue
                data = AttrDict()
                order_num = row[ORDER_NUM]
                if only_order_no and order_num != only_order_no:
                    continue
                print('  processing row %d, order %s' % (i, order_num), verbose=2)
                item = OE.inventory.get(row[ITEM_CODE])
                if not item:
                    # couldn't find the product, record the error
                    errors.append(
                            '<row %3d> order %s: product %s not found'
                                % (i, order_num, row[ITEM_CODE]),
                            )
                    error(' ', errors[-1])
                    continue
                try:
                    fis_row = fis_f328[order_num]
                except KeyError:
                    errors.append('  cannot find %s in FIS' % order_num)
                    error(' ', errors[-1])
                    continue
                data.dept = fis_row[F328.dept_id]
                # the value of fis_row[F328.prod_line] should be the textual
                # representation of an integer between '01' and '99' for a simple order,
                # or an alphabetic code representing a range of lines in a compound order
                try:
                    line = fis_row[F328.prod_line]
                    print('    line is', line, verbose=2)
                    if line.isdigit():
                        # an error here causes us to default to line 98
                        prodline_id = '%02d' % int(fis_row[F328.prod_line])
                        if prodline_id not in line_ids:
                            errors.append(
                                    '<row %3d> order %s: line_id %r does not exist (using 98)'
                                        % (i, order_num, prodline_id),
                                    )
                            error(' ', errors[-1])
                            prodline_id = '98'
                        prodline_ids = [prodline_id]
                    elif line.isalpha():
                        # an error here causes us to skip the line
                        prodline_ids = multistep[line]
                    else:
                        raise ValueError()
                except ValueError:
                    # no product line, record the error
                    errors.append('<row %3d> order %s: no, or bad, product line <%r> (using 98)' % (i, order_num, line))
                    error(' ', errors[-1])
                    prodline_ids = ['98']
                print('    prodline_ids:', prodline_ids, verbose=2)
                steps = len(prodline_ids)
                print('    steps:', steps, verbose=2)
                for step, prodline in enumerate(prodline_ids, start=1):
                    data.line_id = line_ids[prodline].id
                    data.item_id = item
                    data.order_no = order_num
                    if steps > 1:
                        data.order_no += '-%d_%d' % (step, steps)
                    print('    data.order_no:', data.order_no, verbose=2)
                    data.confirmed = (False, 'fis')[fis_row[F328.order_confirmed] == 'Y']
                    data.ordered_qty = fis_row[F328.qty_on_order]
                    try:
                        sched_date = fix_date(row[DATE], format='ymd')
                    except ValueError:
                        sched_date = ''
                    if not sched_date:
                        # no schedule date, record the error
                        errors.append(
                                '<row %3d> order %s: missing or invalid schedule date'
                                    % (i, order_num),
                                )
                        error(' ', errors[-1])
                        data.schedule_date = False
                    else:
                        data.schedule_date = date_to_str(sched_date)
                    data.completed_fis_qty = fis_row[F328.units_produced] or False
                    if data.completed_fis_qty:
                        data.finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
                        if data.finish_date:
                            finish_datetime = DateTime.combine(data.finish_date, Time(17, 0, 0)).datetime()
                            data.finish_date = datetime_to_str(
                                    LOCAL_TIME.normalize(
                                        LOCAL_TIME.localize(finish_datetime)
                                    ))
                    else:
                        data.finish_date = False
                    imported_orders.append(data.order_no)
                    current_records = get_records(
                            OE.conn,
                            'fnx.pd.order',
                            domain=[('order_no','=',data.order_no)],
                            max_qty=1,
                            )
                    if current_records:
                        print('      checking for changed fields', verbose=2)
                        current_record = current_records[0]
                        if not dryrun:
                            update_formula(OE, order_num, data, errors)
                        for k in data.keys():
                            if k == 'order_no':
                                # TODO: remove this if once all orders have the order id attached
                                continue
                            if k.endswith('_id'):
                                if data[k] == current_record[k][0]:
                                    del data[k]
                            elif data[k] == current_record[k]:
                                del data[k]
                        if data:
                            if sched_date:
                                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                                    print('deleting %s: Saturday schedule' % order_num, verbose=2)
                                    if not dryrun:
                                        OE.fnx_pd_order.unlink(current_record.id, context={'script': True})
                                    continue
                                elif (sched_date - today).days > 21:
                                    print('deleting %s: more than three weeks out' % order_num, verbose=2)
                                    if not dryrun:
                                        OE.fnx_pd_order.unlink(current_record.id, context={'script': True})
                                    continue
                            print('updating %s' % row[ORDER_NUM], verbose=2)
                            for key in data:
                                if key == 'order_no':
                                    # TODO: remove this if once all orders have the order id attached
                                    continue
                                elif data[key] != current_record[key]:
                                    print('  %s: %r -> %r' % (key, current_record[key], data[key]), verbose=2)
                                else:
                                    print('  oops, forgot to delete key', key)
                            if not dryrun:
                                # data.order_id = order_ids[data.order_no].id
                                OE.fnx_pd_order.write(current_record.id, dict(data), context={'script': True})
                    elif sched_date and Weekday.from_date(sched_date) is Weekday.SATURDAY:
                        print('skipping %s: Saturday schedule' % order_num, verbose=2)
                        continue
                    else:
                        if not dryrun:
                            print('creating %s' % row[ORDER_NUM], 'with:\n', data, verbose=2)
                            order_id = OE.fnx_pd_order.create(dict(data), context={'script': True})
                            order_ids[data.order_no] = AttrDict(id=order_id)
                            update_formula(OE, order_num, data, errors)
            except Exception:
                lines = format_exception(*sys.exc_info())
                error('skipping %s due to error:' % order_num)
                error(''.join(lines))

    return imported_orders, errors

def check_open_orders(OE, ignore=(), dryrun=False):
    global fis_f328
    fis_f328 = fisData(328, keymatch='10%s000010000')
    today = Date.today()
    oe_open_orders = get_records(
            OE.conn,
            'fnx.pd.order',
            fields=['id', 'completed_fis_qty', 'order_no', 'schedule_date', 'state'],
            domain=[('order_no','not in',ignore),('state','not in',['complete','cancelled'])],
            )
    print('checking %d open orders in OE' % len(oe_open_orders))
    for open_order in oe_open_orders:
        data = AttrDict()
        print('   order %s' % open_order.order_no, end=' --> ', verbose=2)
        try:
            order_no = open_order.order_no.split('-')[0]
            fis_row = fis_f328[order_no]
        except KeyError:
            # no longer present, delete
            print('deleting missing order: %s' % open_order.order_no, verbose=2)
            if not dryrun:
                OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
            continue
        else:
            status = fis_row[F328.produced]
            sched_date = fix_date(fis_row[F328.prod_sched_date], format='ymd') or False
            if sched_date:
                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                    print('deleting %s: Saturday schedule' % open_order.order_no, verbose=2)
                    if not dryrun:
                        OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                elif (sched_date - today).days > 21:
                    print('deleting %s: more than three weeks out' % open_order.order_no, verbose=2)
                    if not dryrun:
                        OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                data.schedule_date = str(sched_date)
            print('  using %r' % sched_date, end=' . . . ', verbose=2)
            finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
            if finish_date:
                finish_datetime = DateTime.combine(finish_date, Time(17, 0, 0)).datetime()
                data.finish_date = datetime_to_str(
                        LOCAL_TIME.normalize(
                            LOCAL_TIME.localize(finish_datetime)
                        ))
            qty = fis_row[F328.units_produced] or False
            if qty and qty != open_order.completed_fis_qty:
                data.completed_fis_qty = fis_row[F328.units_produced]
        if status == 'Y':
            state = 'complete'
        elif status == 'X':
            state = 'cancelled'
        elif status in 'P N':
            state = None
        else:
            # unknown, skip until tomorrow and hope somebody fixes it
            print('order %s: unknown status %r'
                    % (open_order.order_no, fis_row[F328.produced]), end=' . . . ',
                    )
            state = None
        if state and state != open_order.state:
            data.state = state
        if data:
            print('updating with: %s' % (dict(data), ), verbose=2)
            if not dryrun:
                OE.fnx_pd_order.write([open_order.id], dict(data), context={'script': True})
        else:
            print()

def update_formula(OE, order_num, data, errors):
    print('        updating formula for', order_num)
    print('          current data:', data)
    sales_header = fis_f328[order_num]
    # pad the formula to 10 chars
    formula_id_rev = '%-10s' % sales_header[F328.formula_id], sales_header[F328.formula_rev]
    formula_header = fis_f320[formula_id_rev]
    # get currently existing ingredients
    existing_ingredients = dict(
            (r.name, r)
            for r in get_records(
                OE.fnx_pd_ingredient,
                domain=[('order_no','=',order_num)],
                fields=['id', 'name', 'order_id', 'item_id', 'qty_needed', 'qty_desc'],
                ))
    # assemble list of ingredients, creating any that are missing
    target_item, ingreds = get_order_ingredients(order_num, include_null=False)
    print('           ingredients:', ingreds)
    ingreds_ids = []
    for item_xml_id, key, rec, _ in ingreds:
        if item_xml_id == target_item:
            continue
        item_id = OE.inventory.get(item_xml_id)
        print('        item id: %r' % (item_id, ), verbose=2)
        print('        item xml id: %r' % (item_xml_id, ), verbose=2)
        if item_id is None:
            try:
                item_id = OE.product.search([('xml_id','=',item_xml_id)])[0]
            except IndexError:
                print('item %r not found' % (item_iml_id, ), verbose=2)
                errors.append('unable to find ingredient %r in order %s' % (item_xml_id, order_num))
                OE.fnx_pd_ingredient.unlink(ingreds_ids)
                ingreds_ids = []
                break
        qty = rec[F329.qty_batch_1]
        um = rec[F329.units_batch_1]
        name = '%s:%s' % (order_num, item_xml_id)
        print('        name:', name, verbose=2)
        ingred = existing_ingredients.get(name)
        if ingred is None:
            try:
                ingreds_ids.append(OE.fnx_pd_ingredient.create({
                    'name':name,
                    'order_id':order_ids[order_num].id,
                    'item_id':item_id,
                    'qty_needed':qty,
                    'qty_desc':um,
                    }))
            except Fault as exc:
                error('error creating %r --> %s' % (name, exc.faultCode.replace('\n\n', ':  ')))
                continue
        else:
            # check that the important bits match
            ingredient = AttrDict()
            if ingred.order_id.id != order_ids[order_num].id:
                ingredient.order_id = order_ids[order_num].id
            if ingred.item_id != item_id:
                ingredient.item_id = item_id
            if ingred.qty_needed != qty:
                ingredient.qty_needed = qty
            if ingred.qty_desc != um:
                ingredient.qty_desc = um
            if ingredient:
                OE.fnx_pd_ingredient.write(ingred.id, dict(ingredient))
            ingreds_ids.append(ingred.id)
    remove_ingreds_ids = OE.fnx_pd_ingredient.search(
            [('order_id','=',order_num),('id','not in',ingreds_ids)],
            )
    if remove_ingreds_ids:
        OE.fnx_pd_ingredient.unlink(remove_ingreds_ids)
    if ingreds_ids:
        data.ingredient_ids = [(6, 0, ingreds_ids)]
    # add the formula details
    data.formula_code ='%s [%s-%s]' % (formula_header[F320.desc], formula_id_rev[0].strip(), formula_id_rev[1])
    data.coating = formula_header[F320.coating]
    data.allergens = formula_header[F320.allergens]

def update_order(values):
    pass


Main()
