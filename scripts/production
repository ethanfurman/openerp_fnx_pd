#!/usr/local/sbin/suid-python --virtualenv
# imports
from __future__ import print_function

from aenum import IntEnum
from antipathy import Path
import sys

import email
import os
import pwd
import shutil
import time
from ast import literal_eval
from collections import defaultdict
from dbf import Date, Time, DateTime
from logging import INFO, getLogger, Formatter, handlers
from openerplib import AttrDict, get_connection, get_records, Many2One, Query
from openerplib.dates import LOCAL_TIME, date_to_str, datetime_to_str
from pandaemonium import PidLockFile, AlreadyLocked
from scription import *
from updates.fis_schema import F135, F320, F328, F329
from VSS.constants import IndexEnum, Weekday
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_date
from VSS.xl import open_workbook
from VSS.finance import FederalHoliday
from tools import combine_by_value, Model
from traceback import format_exception
from xmlrpclib import Fault

VIRTUAL_ENV = os.environ['VIRTUAL_ENV']
logger = getLogger()
logger.setLevel(INFO)
_handler = handlers.TimedRotatingFileHandler(
        '%s/var/log/fnx_pd.log' % VIRTUAL_ENV,
        when='midnight',
        backupCount=30,
        )
_formatter = Formatter('%(asctime)s %(funcName)-25s %(message)s')
_handler.setFormatter(_formatter)
logger.addHandler(_handler)
del _handler, _formatter

SOURCE = Path('%s/var/fis/production/' % VIRTUAL_ENV)
ARCHIVE = Path('%s/var/openerp/archive/fnx_pd/' % VIRTUAL_ENV)
ERRORS = Path('%s/var/openerp/archive/fnx_pd/error' % VIRTUAL_ENV)
CONFIG = Path('%s/config/fnx.ini' % VIRTUAL_ENV)

try:
    OPENERP = tuple(pwd.getpwnam('openerp')[2:4])
except KeyError:
    OPENERP = None
IS_ROOT = os.geteuid() == 0

try:
    settings = OrmFile(CONFIG, section='openerp')
except Exception:
    echo('WARNING: unable to process configfile; all parameters must be specified')
    HOST = ''
    USER = ''
    DB = ''
    PW = ''
else:
    HOST = settings.host
    USER = settings.user
    DB = settings.db
    PW = settings.pw


Q = QAll_C = IndexEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )

process_failure_mail = """\
To: %s
From: FnxPD <noreply@sunridgefarms.com>
Date: %s
Subject: Failures during processing of QALL spreadsheet

The following errors were detected during nightly processing:

%s
"""

C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

QAll_C = IntEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )
HEADER, EMAIL, DEPT, PROD_LINE, TYPE, ITEM_CODE, ITEM_DESC, \
    ORDER_NUM, CONFIRMED, QTY, DATE, DAY, COATING, ALLERGENS = QAll_C

TODAY = Date.today()

# API

@Script(
        dryrun=Spec('do not make changes, only show what changes would be made', FLAG, None),
        list_records=Spec('list added/changed records', FLAG, None),
        raise_on_exception=Spec('do not ignore exceptions', FLAG, abbrev=('r', 'raise')),
        )
def main(dryrun, list_records, raise_on_exception):
    global config, oe, errors, DRYRUN, LIST_RECORDS, RAISE_ON_EXCEPTION, VIEW_TYPE, BORDER, script_verbosity, today, cutoff
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path': Path})
    oe = config.openerp
    print('connecting to OpenERP')
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    if list_records:
        LIST_RECORDS = True
        if not script_verbosity:
            script_verbosity = 1
    RAISE_ON_EXCEPTION = raise_on_exception
    VIEW_TYPE = 'none' if LIST_RECORDS else 'percent'
    BORDER = 'box' if LIST_RECORDS and script_verbosity > 1 else None
    today = Date.today()
    cutoff = FederalHoliday.next_business_day(today, 15)


@Command(
        table=Spec('which table to update', REQUIRED, choices=['product','production']),
        ids=Spec('ids of records to change', REQUIRED),
        values=Spec('settings to use', REQUIRED),
        )
def manual_update(table, ids, **values):
    connect(HOST, DB, USER, PW)
    ids = [int(i) for i in ids.replace(',',' ').split()]
    for key, value in values.items():
        for t in (int, float):
            try:
                value = t(value)
                break
            except ValueError:
                pass
    table = oe.conn.get_model({'product':'product.product', 'production':'fnx_pd.production'}[table])
    table.write(ids, values)

@Command(
        file_to_process=('order to add/update in system', ),
        order=('specific order number from file to process', ),
        dryrun=('do not update tables', FLAG),
        )
def process_qall(file_to_process='', order='', dryrun=False):
    "imports a production spreadsheet into FnxPd"
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    oe.fnx_pd_order = oe.conn.get_model('fnx.pd.order')
    oe.fnx_pd_ingredient = oe.conn.get_model('fnx.pd.ingredient')
    oe.product = oe.conn.get_model('product.product')
    print('getting inventory...')
    oe.inventory = dict([
        (r.xml_id, r.id)
        for r in get_records(
                oe.conn,
                'product.product',
                fields=['id', 'xml_id'],
                domain=[('module','=','F135')],
                )])
    print('getting orders...')
    oe.orders = dict([
        (r.order_no, r)
        for r in get_records(
                oe.conn,
                'fnx.pd.order',
                )])
    print('getting ingredients...')
    oe.ingredients = dict([
        (r.name, r)
        for r in get_records(
                oe.conn,
                'fnx.pd.ingredient',
                fields=['id', 'name', 'order_id', 'order_no', 'item_id', 'qty_needed', 'qty_desc'],
                )])
    for file in files:
        print('using file:', file)
        imported_orders, errors = import_spreadsheet(file, order or None, dryrun=dryrun)
        if not order:
            check_open_orders(dryrun=dryrun)
        if errors:
            if CONFIG.db.startswith('test') or dryrun:
                # do not send mail from test machines nor during dry runs
                abort('errors during processing')
            [fnxpd_manager] = get_records(
                    oe.conn,
                    'ir.model.data',
                    domain=[('module','=','fnx_pd'),('model','=','res.groups'),('name','=','group_fnx_pd_manager')],
                    )
            [fnxpd_manager_group] = get_records(
                    oe.conn,
                    'res.groups',
                    domain=[('id','=',fnxpd_manager.res_id)],
                    )
            managers = get_records(
                    oe.conn,
                    'res.users',
                    domain=[('id','in',fnxpd_manager_group.users)],
                    fields=['id','login','email'],
                    )
            emails = [mgr.email for mgr in managers if mgr.id != 1 and mgr.email]
            if emails:
                print('-------', file=stderr)
                print('sending to: ', ', '.join(emails), file=stderr)
                mail_errors = mail(
                    'mail.sunridgefarms.com',
                    25,
                    process_failure_mail % (
                        ', '.join(emails),
                        email.utils.formatdate(email.utils.mktime_tz(time.localtime()+(None,))),
                        '\n'.join(errors),
                        )
                    )
                if mail_errors:
                    print('unable to mail: ', mail_errors.items(), sep='\n   ', file=stderr)
                raise SystemExit("errors during processing, mail attempted")
            else:
                raise SystemExit("errors during processing")

@Command(
        dryrun=('do not update tables', FLAG),
        )
def open_orders(dryrun=False):
    "check open orders and close if necessary"
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    oe.fnx_pd_order = oe.conn.get_model('fnx.pd.order')
    check_open_orders(dryrun=dryrun)

@Command(
        order_no=Spec('fix absent/wrong order number', FLAG),
        )
def repair(order_no):
    "fix broken orders"
    fix_order_no = order_no
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    # following list will grow over time; if no flags are set attempt
    # to fix all possible problems
    if not any (fix_order_no, ):
        fix_order_no = True
    # get all order ingredients
    fnx_pd_order = oe.con.get_model('fnx.pd.order')
    orders = dict(
            (r.order_no, r.id)
            for r in fnx_pd_order.read([('id','!=',0)])
            )
    fnx_pd_ingredient = oe.con.get_model('fnx.pd.ingredient')
    ingredients = fnx_pd_ingredient.read([('id','!=',0)])
    for ingred in ingredients:
        if fix_order_no and not ingred.order_no:
            # FIXME
            pass
            orders

@Command(
        old=('file with older order information', ),
        new=('file with newer order information', ),
        order=('individual orders to check', MULTI),
        )
def diff(old, new, order):
    old_qall = convert_spreadsheet(old)
    new_qall = convert_spreadsheet(new)
    new_orders = dead_orders = changed_orders = 0
    for i, order_no in enumerate(sorted(set(old_qall.keys() + new_qall.keys()))):
        if order and order_no not in order:
            continue
        old_order = old_qall.get(order_no)
        new_order = new_qall.get(order_no)
        if old_order == new_order:
            continue
        elif new_order is None:
            dead_orders += 1
            print('deleted order: %s' % order_no)
            continue
        elif old_order is None:
            new_orders += 1
            print('new order: %s' % order_no)
            continue
        changed_orders += 1
        print('changes in order: %s' % order_no)
        for field in ('user','dept','line','item','desc','conf','qty','date','day','coating','allergens'):
            if old_order[field] != new_order[field]:
                print('   %s:  %-50s  -->  %s' % (field, old_order[field], new_order[field]))
    print('total orders: %r\ndeleted orders: %r\nnew orders: %r\nchanged orders: %r'
            % (i, dead_orders, new_orders, changed_orders), border='box')


@Command(
        purge=('remove found duplicates', FLAG),
        )
def duplicates(purge):
    "find duplicate order numbers"
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    fnx_pd_order = oe.get_model('fnx.pd.order')
    all_orders = {}
    for rec in get_records(
            fnx_pd_order,
            domain=[('order_no','!=','CLEAN')],
            fields=['id', 'order_no', 'state', 'item_id', 'line_id', 'schedule_date'],
        ):
        all_orders.setdefault(rec.order_no, []).append(rec)
    last_order = None
    processed = set()
    to_be_purged = set()
    check_for_purge = dict()
    for order_no, orders in sorted(all_orders.items()):
        found_old = False
        if len(order_no) > 6 and order_no[:6] not in processed:
            processed.add(order_no[:6])
            # check for old 6-digit order
            old_order = all_orders.get(order_no[:6])
            if old_order is not None:
                found_old = True
                [old_order] = old_order
                to_be_purged.add(old_order.id)
        if found_old:
            if order_no[:6] != last_order:
                echo()
                last_order = order_no[:6]
            echo('%s\n------------' % order_no[:6])
            echo('   %-60s  %-30s  %10s  %s'
                    % (old_order.item_id[1], old_order.line_id[1], old_order.schedule_date, old_order.state)
                    )
        if len(orders) < 2:
            continue
        if order_no[:6] != last_order:
            echo()
            last_order = order_no[:6]
        echo('%s\n------------' % order_no)
        for order in orders:
            check_for_purge.setdefault(order_no, []).append(order)
            echo('   %-60s  %-30s  %10s  %s'
                    % (order.item_id[1], order.line_id[1], order.schedule_date, order.state)
                    )
    echo()
    if purge:
        # compare orders in check_for_purge against FIS tables to determine which to keep
        # and which to delete
        ifpp = fisData(328, subset='10%s')
        line_ids = {}
        oe_production_lines = {}
        for line in get_records(
                oe,
                'fis_integration.production_line',
                fields=['id','xml_id','name'],
            ):
            line_ids[line.id] = line
            oe_production_lines[line.xml_id] = [Many2One(line.id, line.name)]
        for multiline in get_records(
                oe,
                'fnx.pd.multiline',
                fields=['key', 'line_ids'],
            ):
            lines = []
            for ml in multiline.line_ids:
                lines.append(Many2One(ml, line_ids[ml].name))
            oe_production_lines[multiline.key] = lines
        for oe_order_no, oe_orders in sorted(check_for_purge.items()):
            fis_order_no = oe_order_no[:6]
            [key_rec] = ifpp.get_subset(fis_order_no)
            fis_order = key_rec[1]
            multiline = oe_production_lines[fis_order[F328.prod_line]]
            step = int(oe_order_no[7])
            index = step - 1
            correct_line = multiline[index]
            for oe_order in oe_orders:
                if oe_order.line_id != correct_line:
                    to_be_purged.add(oe_order.id)
        fnx_pd_order.unlink(tuple(to_be_purged))
        echo('%d orders removed' % len(to_be_purged))


@Command(
        file=('production order to add/update in system', OPTION, 'f', Path),
        directory=('directory of production orders to add/update in system', OPTION, 'd', Path),
        abort_on_error=Spec('abort on error', FLAG, 'a', usage='abort'),
        )
def release(file, directory=SOURCE, abort_on_error=False):
    """
    Markem label has been generated, set status to Released

    Use files with the structure of

        order={
          'line_no': '07',
          'status': 'sequenced',
          'markem': '...',
          }

    to update OpenERP.FnxPD and set the status to 'Released to Floor'.
    """
    logger.info('release(file=%r, directory=%r', file, directory)
    print('release(file=%r, directory=%r' % (file, directory))
    global fnxpd
    fnxpd = oe.get_model('fnx.pd.order')
    if file:
        files = [file]
        lock = None
    else:
        if not directory.exists():
            abort('directory %s does not exist' % directory)
        try:
            lock = PidLockFile('/var/run/fnxpd-order_release.pid', timeout=30)
            lock.seal()
        except AlreadyLocked:
            return
        files = get_files(directory, 'PD-')
        if not files:
            lock.release()
            return
    print('processing %s' % ', '.join([s.filename for s in files]))
    try:
        failures = False
        bad_orders = []
        for file in files:
            try:
                order = get_order(file)
                order['last_release_date'] = TODAY
                logger.info(
                        '%s: %s',
                        file.name,
                        ', '.join('%s=%r' % (k, v) for k, v in sorted(order.items()))
                        )
                update_order(order)
                dest = ARCHIVE
            except (BadFormat, MissingOrder) as exc:
                if abort_on_error:
                    raise
                error('%s: %s %s' % (file, exc.__class__.__name__, exc.message or exc.args))
                with open(file) as f:
                    data = '================\n%s\n----------------\n' % file
                    data += f.read() + '\n'
                    bad_orders.append(data)
                # failing.append('%s: %s' % (file, exc.message or exc.args))
                dest = ERRORS
                failures = True
            except (Exception, ), exc:
                if abort_on_error:
                    raise
                logger.exception('error processing %s', file)
                error('%s: %s %s' % (file, exc.__class__.__name__, exc.message or exc.args))
                # failing.append('%s: %s' % (file, exc.message or exc.args))
                dest = None
                failures = True
                continue
            if dest:
                archive(file, dest)
        if failures:
            error('\n'.join(bad_orders))
            raise SystemExit(-1)
    finally:
        if lock:
            lock.release()
    print('done.')


@Command(
        file=('production order to add/update in system', OPTION, 'f', Path),
        directory=('directory of production orders to add/update in system', OPTION, 'd', Path),
        abort_on_error=Spec('abort on error', FLAG, 'a', usage='abort'),
        )
def schedule(file, directory=SOURCE, abort_on_error=False):
    """
    Update the scheduled date of the listed orders.

    Use files with the structure of

        {'20220829': [312752, 313516, ...]}

    to update the scheduled date of the listed orders.
    """
    logger.info('schedule(file=%r', file)
    print('schedule(file=%r, directory=%r, abort_on_error=%r)' % (file, directory, abort_on_error))
    global fnxpd
    fnxpd = oe.get_model('fnx.pd.order')
    if file:
        files = [file]
        lock = None
    else:
        if not directory.exists():
            abort('directory %s does not exist' % directory)
        try:
            lock = PidLockFile('/var/run/fnxpd-order_schedule.pid', timeout=30)
            lock.seal()
        except AlreadyLocked:
            return
        files = get_files(directory, 'PDS-')
        if not files:
            lock.release()
            return
    print('processing %r' % ', '.join([s.filename for s in files]))
    try:
        failures = False
        bad_orders = []
        for file in files:
            with open(file) as fh:
                schedules = literal_eval(fh.read())
            for date, orders in schedules.items():
                try:
                    date = Date.strptime(date, '%Y%m%d')
                except ValueError as exc:
                    if abort_on_error:
                        raise
                    message = '%s: %s %s' % (file, exc.__class__.__name__, exc.message or exc.args)
                    bad_orders.append(message)
                    failures = True
                    continue
                for order in orders:
                    try:
                        update_order({
                                'order_no': str(order),
                                'schedule_date':date,
                                'schedule_date_set':True,
                                'state':'sequenced',
                                })
                    except MissingOrder as exc:
                        if abort_on_error:
                            raise
                        message = '%s: %s %s' % (file, exc.__class__.__name__, exc.message or exc.args)
                        bad_orders.append(message)
                        failures = True
                    except Exception as exc:
                        if abort_on_error:
                            raise
                        logger.exception('error processing %s', file)
                        message = '%s: %s %s' % (file, exc.__class__.__name__, exc.message or exc.args)
                        bad_orders.append(message)
                        failures = True
            archive(file)
        if failures:
            error('\n'.join(bad_orders))
            raise SystemExit(-1)
    finally:
        if lock:
            lock.release()
    print('done.')


# helpers

class BadFormat(Exception):
    "order is incomplete"

class MissingOrder(Exception):
    "unable to find order"

class TooManyOrders(Exception):
    "found too many orders"

class CancelledOrder(Exception):
    "order has been cancelled"

class MissingFIS(Exception):
    "unable to find document in FIS"

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

ignored_ingredients = set([
        # nutritional info
        '910000', '910001', '910002', '910003', '910004', '910005', '910006',
        '910007', '910008',
        # misc
        '900110', '900111', '900112', '900113', '900115', '900200', '900205',
        '900210', '900215', '900230', '900235', '900291', '900448', '900485',
        '900700', '900715', '900900', '900910', '900915', '900917', '900918',
        '900920', '900921', '900922', '900930', '900932', '900935', '900940',
        '900950', '900951', '900952', '900954', '900960', '900962', '900965',
        '900970', '900975', '900980', '900983', '900985', '900986', '900995',
        '901000', '901005', '901006', '901008', '901009', '901010', '901011',
        '901012', '901013', '901014', '901019', '901021', '901023', '901028',
        '901031', '901040', '901041', '901042', '901043', '901044', '901045',
        '901046', '901050', '901065', '901091', '901093', '901095', '901097',
        '901098', '901100', '901101', '901102', '901105', '901107', '901111',
        '901112', '901113', '901117', '901128', '901130', '901131', '901132',
        '901133', '901134', '901135', '901200', '901210', '901245', '901265',
        '901279', '901285', '901286', '901288', '901291', '901292', '901293',
        '901295', '901298', '901302', '901315', '901327', '901329', '901331',
        '901338', '901340', '901352', '901370', '901372', '901375', '901380',
        '901400', '901401', '901403', '901404', '901406', '901407', '901409',
        '901425', '901451', '901465', '901467', '901468', '901469', '901500',
        '901502', '901505', '901507', '901510', '901520', '901521', '901522',
        '901523', '901524', '901525', '901530', '901531', '901532', '901533',
        '901570', '901571', '901572', '901630', '902002', '902003', '902004',
        '902005', '902006', '902007', '902008', '902022', '902025', '902027',
        '902071', '902073', '902076', '902078', '902101', '902105', '902120',
        '902125', '902126', '902127', '902128', '902130', '902134', '902136',
        '902140', '902143', '902150', '902152', '902280', '902281', '902282',
        '902283', '902288', '902495', '902498', '902499', '902500', '902501',
        '902502', '902503', '902663', '904108', '905001', '905005', '905008',
        '905010', '905015', '905016', '905685', '905700', '905703', '905728',
        '906017', '906050', '906063', '906212', '906220', '906223', '906225',
        '906704', '906705', '906706', '906707', '907134', '907135', '907149',
        '909450', '910103', '910109', '913810', '914108', '916105', '916107',
        '919163', '919164', '919165', '919180', '921112', '921113', '921115',
        '921117', '921120', '921121', '921122', '921123', '921124', '921125',
        '921126', '921127', '921128', '921129', '921130', '921132', '921133',
        '921138', '921211', '921212', '921300', '921308', '921310', '921312',
        '921313', '921314', '921315', '921320', '921322', '921325', '921330',
        '921335', '921336', '921337', '921338', '921340', '921342', '921345',
        '922162', '922166', '922167', '922600', '922601', '922602', '922603',
        '922604', '922605', '922606', '922607', '922608', '922609', '922610',
        '922611', '922612', '922613', '922614', '922615', '922616', '922617',
        '922618', '923610', '923613', '923614', '923615', '923616', '923617',
        '923618', '923619', '923621', '923622', '929340', '929450', '929550',
        '929551', '929552', '929553', '929610', '936148', '936149', '936150',
        '936151', '936152', '936153', '936154', '939105', '940105', '940200',
        '940201', '940202', '940205', '940210', '940215', '940220', '940225',
        '949448', '949495', '949555', '950800', '950808', '950815', '950817',
        '950820', '950830', '950831', '950832', '950834', '950837', '950925',
        '950926', '950927', '950929', '961005', '961007', '967005', '967052',
        '968103', '968107', '969025', '969027', '969031', '970000', '970150',
        '970220', '970221', '971050', '971051', '971052', '981040', '981095',
        '981097', '981112', '981312', '981400', '985002', '985003', '985103',
        '986063', '986064', '986065', '986066', '986067', '986700', '990103',
        '990605', '995000', '995100', '999016', '999017', '999018',
        # freight charges
        '967001', '967003', '967004', '993030', '993040', '996000', '996001',
        '996002', '996333', '996555', '997090',
        ])


def archive(src_file, dest=ARCHIVE):
    print('archiving %r' % (src_file, ))
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    if basename.startswith('PD-'):
        basename = basename[3:]
    existing = dest.glob(basename+'*')
    existing.sort()
    print('found file %r' % (existing, ))
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].rsplit('_', 1)
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)
    if IS_ROOT and OPENERP:
        Path(dst_file).chown(*OPENERP)

def connect(hostname, database, user, password):
    global oe
    oe = AttrDict()
    print('connecting to %s:%s' % (hostname, database))
    oe.conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    return oe

def get_files(source=SOURCE, pre=''):
    files = [
            source/f
            for f in source.listdir()
            if f.startswith(pre)
            ]
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    result = AttrDict(g['order'])
    status = result.pop('status', None) or result.pop('state')
    if status in StatusCode:
        status = StatusCode[status]
    result['state'] = status
    return result

def import_spreadsheet(file_name, only_order_no, dryrun):
    '''
    add/update orders from spreadsheet; also add as-yet-unreferenced formulai
    '''
    # production date, production line should not be updated from QALL once
    # they have been changed in OpenERP
    global fis_f135, fis_f320, fis_f328, fis_f329
    fis_f135 = fisData('NVTY1', keymatch="%s101000    101**")   # NVTY
    fis_f320 = fisData(320, keymatch='10%s  %s0')               # IFMS
    fis_f328 = fisData(328, keymatch='10%s000010000')           # IFPP0
    fis_f329 = fisData('IFPP1', subset="10%s")                  # IFPP1
    errors = []
    # list of imported current orders so that non-current orders still on file
    # can be flagged completed/cancelled
    imported_orders = []
    line_ids = dict(
            (r.xml_id, r) for r in get_records(
                oe.conn,
                'fis_integration.production_line',
                fields=['id','xml_id'],
            ))
    today = Date.today()
    # get current orders and construct a dict of (schedule_date, min(sequence))
    multilines = dict([(r.key, r.line_ids) for r in get_records(oe.conn, 'fnx.pd.multiline', fields=['key', 'line_ids'])])
    multistep = {}
    for key, multiline in multilines.items():
        lines = get_records(oe.conn, 'fnx.pd.multiline.entry', ids=multiline, fields=['line_id'])
        ids = [l.line_id[0] for l in lines]
        sequence = [(i, l.line_id[0]) for i, l in enumerate(lines)]
        xml_ids_map = dict([(x.id, x) for x in get_records(oe.conn, 'fis_integration.production_line', ids=ids, fields=['xml_id'])])
        xml_ids = []
        for seq, xid in sequence:
            xml_ids.append(xml_ids_map[xid])
        multistep[key] = [r.xml_id for r in xml_ids]
    for key, lines in multistep.items():
        print(key, lines, verbose=2)
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        last_row = None
        rows = list(sheet.rows(start_row=1))
        print('processing %d rows' % len(rows))
        for i, row in enumerate(rows, start=1):
            try:
                # try to bail early: closed order and date older than three months?
                order_num = row[Q.ORDER_NUM]
                # print('\n%9s' % order_num, end='  ')
                try:
                    sched_date = fix_date(row[Q.DATE], format='ymd')
                except ValueError:
                    sched_date = ''
                # print('%15s' % sched_date, end='')
                if row == last_row:
                    # print('=', end='')
                    continue
                data = AttrDict()
                if only_order_no and order_num != only_order_no:
                    continue
                print('  processing row %d, order %s' % (i, order_num), verbose=2)
                item = oe.inventory.get(row[Q.ITEM_CODE])
                if not item:
                    # couldn't find the product, record the error
                    errors.append(
                            '<row %3d> order %s: product %s not found'
                                % (i, order_num, row[Q.ITEM_CODE]),
                            )
                    # error(' ', errors[-1])
                    # print('p', end='')
                    continue
                try:
                    fis_row = fis_f328[order_num]
                except KeyError:
                    errors.append('  cannot find %s in FIS' % order_num)
                    # error(' ', errors[-1])
                    # print('f', end='')
                    continue
                data.dept = fis_row[F328.dept_id]
                # the value of fis_row[F328.prod_line] should be the textual
                # representation of an integer between '01' and '99' for a simple order,
                # or an alphabetic code representing a range of lines in a compound order
                try:
                    line = fis_row[F328.prod_line]
                    print('    line is', line, verbose=2)
                    if line.isdigit():
                        # an error here causes us to default to line 98
                        prodline_id = '%02d' % int(fis_row[F328.prod_line])
                        if prodline_id not in line_ids:
                            errors.append(
                                    '<row %3d> order %s: line_id %r does not exist (using 98)'
                                        % (i, order_num, prodline_id),
                                    )
                            error(' ', errors[-1])
                            prodline_id = '98'
                        prodline_ids = [prodline_id]
                    elif line.isalpha():
                        # an error here causes us to skip the line
                        prodline_ids = multistep[line]
                    else:
                        raise ValueError()
                except ValueError:
                    # no product line, record the error
                    errors.append('<row %3d> order %s: no, or bad, product line <%r> (using 98)' % (i, order_num, line))
                    error(' ', errors[-1])
                    prodline_ids = ['98']
                print('    prodline_ids:', prodline_ids, verbose=2)
                steps = len(prodline_ids)
                print('    steps:', steps, verbose=2)
                for step, prodline in enumerate(prodline_ids, start=1):
                    data.line_id = line_ids[prodline].id
                    data.item_id = item
                    data.order_no = order_num
                    if steps > 1:
                        data.order_no += '-%d_%d' % (step, steps)
                    print('    data.order_no:', data.order_no, verbose=2)
                    current_oe_order = oe.orders.get(data.order_no)
                    if current_oe_order:
                        if 'state' not in current_oe_order:
                            error('missing state field')
                            abort(current_oe_order)
                        elif current_oe_order.state in ('complete','cancelled'):
                            # print('s', end='')
                            continue
                    data.confirmed = (False, 'fis')[fis_row[F328.order_confirmed] == 'Y']
                    data.ordered_qty = fis_row[F328.qty_on_order]
                    if not sched_date:
                        # no schedule date, record the error
                        errors.append(
                                '<row %3d> order %s: missing or invalid schedule date'
                                    % (i, order_num),
                                )
                        error(' ', errors[-1])
                        data.schedule_date = False
                    else:
                        data.schedule_date = date_to_str(sched_date)
                    data.completed_fis_qty = fis_row[F328.units_produced] or False
                    if data.completed_fis_qty:
                        data.finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
                        if data.finish_date:
                            finish_datetime = DateTime.combine(data.finish_date, Time(17, 0, 0)).datetime()
                            data.finish_date = datetime_to_str(
                                    LOCAL_TIME.normalize(
                                        LOCAL_TIME.localize(finish_datetime)
                                    ))
                    else:
                        data.finish_date = False
                    imported_orders.append(data.order_no)
                    if current_oe_order:
                        print('      checking for changed fields', verbose=2)
                        if not dryrun:
                            pass
                            # update_formula(order_num, data, errors)
                        for k in data.keys():
                            if k == 'order_no':
                                # TODO: remove this if once all orders have the order id attached
                                continue
                            if k.endswith('_id'):
                                if data[k] == current_oe_order[k][0]:
                                    del data[k]
                            elif data[k] == current_oe_order[k]:
                                try:
                                    old_values = data._values.copy()
                                    old_keys = data._keys[:]
                                    del data[k]
                                except ValueError:
                                    print('FAILURE', k)
                                    print(old_values)
                                    print(old_keys)
                                    raise
                        if data:
                            if sched_date:
                                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                                    print('deleting %s: Saturday schedule' % order_num, verbose=2)
                                    if not dryrun:
                                        oe.fnx_pd_order.unlink(current_oe_order.id, context={'script': True})
                                    continue
                                elif (sched_date - today).days > 21:
                                    print('deleting %s: more than three weeks out' % order_num, verbose=2)
                                    if not dryrun:
                                        oe.fnx_pd_order.unlink(current_oe_order.id, context={'script': True})
                                    continue
                            print('updating %s' % row[Q.ORDER_NUM], verbose=2)
                            for key in data:
                                if key == 'order_no':
                                    # TODO: remove this if once all orders have the order id attached
                                    continue
                                elif data[key] != current_oe_order[key]:
                                    print('  %s: %r -> %r' % (key, current_oe_order[key], data[key]), verbose=2)
                                else:
                                    print('  oops, forgot to delete key', key, verbose=2)
                            if not dryrun:
                                oe.fnx_pd_order.write(current_oe_order.id, dict(data), context={'script': True})
                    elif sched_date and Weekday.from_date(sched_date) is Weekday.SATURDAY:
                        print('skipping %s: Saturday schedule' % order_num, verbose=2)
                        continue
                    else:
                        if not dryrun:
                            print('creating %s' % row[Q.ORDER_NUM], 'with:\n', data, verbose=2)
                            order_id = oe.fnx_pd_order.create(dict(data), context={'script': True})
                            oe.orders[order_num] = AttrDict(id=order_id)
                            update_formula(order_num, data, errors)
            except Exception:
                lines = format_exception(*sys.exc_info())
                error('skipping %s due to error:' % order_num)
                error(''.join(lines))

    return imported_orders, errors

def check_open_orders(ignore=(), dryrun=False):
    global fis_f328
    fis_f328 = fisData(328, keymatch='10%s000010000')
    today = Date.today()
    oe_open_orders = get_records(
            oe.conn,
            'fnx.pd.order',
            fields=['id', 'completed_fis_qty', 'order_no', 'schedule_date', 'state'],
            domain=[('order_no','not in',ignore),('state','not in',['complete','cancelled'])],
            )
    print('checking %d open orders in OE' % len(oe_open_orders))
    for open_order in oe_open_orders:
        data = AttrDict()
        print('   order %s' % open_order.order_no, end=' --> ', verbose=2)
        try:
            order_no = open_order.order_no.split('-')[0]
            fis_row = fis_f328[order_no]
        except KeyError:
            # no longer present, delete
            print('deleting missing order: %s' % open_order.order_no, verbose=2)
            if not dryrun:
                oe.fnx_pd_order.unlink(open_order.id, context={'script': True})
            continue
        else:
            status = fis_row[F328.produced]
            sched_date = fix_date(fis_row[F328.prod_scheduled_date], format='ymd') or False
            if sched_date:
                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                    print('deleting %s: Saturday schedule' % open_order.order_no, verbose=2)
                    if not dryrun:
                        oe.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                elif (sched_date - today).days > 21:
                    print('deleting %s: more than three weeks out' % open_order.order_no, verbose=2)
                    if not dryrun:
                        oe.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                data.schedule_date = str(sched_date)
            print('  using %r' % sched_date, end=' . . . ', verbose=2)
            finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
            if finish_date:
                finish_datetime = DateTime.combine(finish_date, Time(17, 0, 0)).datetime()
                data.finish_date = datetime_to_str(
                        LOCAL_TIME.normalize(
                            LOCAL_TIME.localize(finish_datetime)
                        ))
            qty = fis_row[F328.units_produced] or False
            if qty and qty != open_order.completed_fis_qty:
                data.completed_fis_qty = fis_row[F328.units_produced]
        if status == 'Y':
            state = 'complete'
        elif status == 'X':
            state = 'cancelled'
        elif status in 'P N':
            state = None
        else:
            # unknown, skip until tomorrow and hope somebody fixes it
            print('order %s: unknown status %r'
                    % (open_order.order_no, fis_row[F328.produced]), end=' . . . ',
                    )
            state = None
        if state and state != open_order.state:
            data.state = state
        if data:
            print('updating with: %s' % (dict(data), ), verbose=2)
            if not dryrun:
                oe.fnx_pd_order.write([open_order.id], dict(data), context={'script': True})
        else:
            print()

def update_formula(order_num, data, errors):
    print('        updating formula for', order_num, verbose=2)
    print('          current data:', data, verbose=2)
    sales_header = fis_f328[order_num]
    # pad the formula to 10 chars
    formula_id_rev = '%-10s' % sales_header[F328.formula_id], sales_header[F328.formula_rev]
    formula_header = fis_f320[formula_id_rev]
    # assemble list of ingredients, creating any that are missing
    target_item, ingreds = get_order_ingredients(order_num, include_null=False)
    print('           ingredients:', ingreds, verbose=2)
    ingreds_ids = []
    for item_xml_id, key, rec, _ in ingreds:
        if item_xml_id == target_item:
            continue
        item_id = oe.inventory.get(item_xml_id)
        print('        item id: %r' % (item_id, ), verbose=2)
        print('        item xml id: %r' % (item_xml_id, ), verbose=2)
        if item_id is None:
            try:
                item_id = oe.product.search([('xml_id','=',item_xml_id)])[0]
            except IndexError:
                print('item %r not found' % (item_xml_id, ), verbose=2)
                errors.append('unable to find ingredient %r in order %s' % (item_xml_id, order_num))
                oe.fnx_pd_ingredient.unlink(ingreds_ids)
                ingreds_ids = []
                break
        qty = rec[F329.qty_batch_1]
        um = rec[F329.units_batch_1]
        name = '%s:%s' % (order_num, item_xml_id)
        print('        name:', name, verbose=2)
        ingred = oe.ingredients.get(name)
        if ingred is None:
            try:
                ingred_values = AttrDict(
                        name=name,
                        order_id=oe.orders[order_num].id,
                        item_id=item_id,
                        qty_needed=qty,
                        qty_desc=um,
                        )
                ingred_values.id = oe.fnx_pd_ingredient.create(dict(ingred_values))
                ingred_values.order_no = order_num
                oe.ingredients[name] = ingred_values
                ingreds_ids.append(ingred_values.id)
            except Fault as exc:
                error('error creating %r --> %s' % (name, exc.faultCode.replace('\n\n', ':  ')))
                continue
        else:
            # check that the important bits match
            ingredient = AttrDict()
            if ingred.order_id != oe.orders[order_num].id:
                ingredient.order_id = oe.orders[order_num].id
            if ingred.item_id != item_id:
                ingredient.item_id = item_id
            if ingred.qty_needed != qty:
                ingredient.qty_needed = qty
            if ingred.qty_desc != um:
                ingredient.qty_desc = um
            if ingredient:
                oe.fnx_pd_ingredient.write(ingred.id, dict(ingredient))
            ingreds_ids.append(ingred.id)
    remove_ingreds_ids = [
            i.id
            for i in oe.ingredients.values()
            if i.order_no == order_num and i.id not in ingreds_ids
            ]
    if remove_ingreds_ids:
        oe.fnx_pd_ingredient.unlink(remove_ingreds_ids)
    if ingreds_ids:
        data.ingredient_ids = [(6, 0, ingreds_ids)]
    # add the formula details
    data.formula_code ='%s [%s-%s]' % (formula_header[F320.desc], formula_id_rev[0].strip(), formula_id_rev[1])
    data.coating = formula_header[F320.coating]
    data.allergens = formula_header[F320.allergens]

def update_order(values):
    # look up the order in values and update
    order_segment = values.pop('order_no')
    order = order_segment.split('-')[0]
    ids = fnxpd.search([('order_no','=like',order)])
    print('found ids:', ids)
    if not ids:
        raise MissingOrder(order_segment)
    else:
        print('updating %r with %r' % (ids, values))
        fnxpd.write(ids, values)

def get_order_ingredients(order, food_only=False, include_null=True):
    # get the order record from 328
    order, order_no = fis_f328[order], order
    item = order[F328.prod_no].strip()
    # then the ingredients
    fulllist = [(rec[F329.ingr_code_batch_1], key, rec) for key, rec in fis_f329.get_subset(order_no)]
    # import pdb; pdb.set_trace()
    foodlist = []
    for ingredient, key, rec in fulllist:
        ingredient = ingredient[:6]
        if ingredient in ignored_ingredients:
            continue
        if rec[F329.qty_batch_1] or include_null:
            if fis_f135.has_key(ingredient):
                if item == ingredient:
                    foodlist.append((ingredient, key, rec, 1)) # the 1 means don't eplode (isself=1)
                    ingredient = "x" + ingredient # XXX this line should be above the previous one, or removed
                elif not food_only or fis_f135[ingredient][F135.net_un_wt] > 0:
                    # net_un_wt > 0 means it's an item that contributes wght (food ingredient?)
                    foodlist.append((ingredient, key, rec, 0))
    return item, foodlist

# from updates_production

def handle_qall(*files):
    print('processing QAll', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    if len(files) > 1:
        abort('only one file can be specified (%r)' % (files, ))
    if files:
        [qall] = files
    else:
        # see if today's qall file exists
        qall_files = sorted(config.network.qall_files.glob(today.strftime('%Y-%m-%d_*')))
        if qall_files:
            qall = qall_files[-1]
        else:
            echo(today.strftime('no QALL file found for %Y-%m-%d'), border='box')
            return
    product_orders = Model(oe.get_model('fnx.pd.order'), 'ifpp0', 'F328', context, RAISE_ON_EXCEPTION)
    # variables used
    added_records = {}
    old_changed_records = {}
    new_changed_records = {}
    deleted_records = {}
    added_count = 0
    deleted_count = 0
    changed_count = 0
    #
    #
    fis_orders = convert_spreadsheet(qall)
    oe_orders = dict(
        (r.order_no, r) for r in get_records(
            oe,
            'fnx.pd.order',
            domain=[('state','in',['draft','sequenced','released','running','stopped'])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set',
                'dept', 'coating', 'allergens',
                ],
        ))
    #
    # rules for orders (failure means order is deleted from, or not entered into, OpenERP):
    # - cannot be scheduled for Saturday
    # - must be within three weeks of today (15 business days)
    # - must be present in FIS
    #
    # rules for order state:
    # - if state in FIS is
    #   - Y --> complete
    #   - X --> cancelled
    #   - P, N, or Space --> no change
    #   - anything else --> no change, and record invalid state
    #
    # trim any FIS orders that fail the first two criteria
    for order_no, order in list(fis_orders.items()):
        if order.day is Weekday.SATURDAY:
            fis_orders.pop(order_no)
        elif cutoff <= order.schedule_date:
            fis_orders.pop(order_no)
        # no longer need the day field
        del order.day
    #
    # above oe_orders only has active orders; now check for inactive orders -- we do this
    # so we don't try to add an existing order
    #
    for order in get_records(
            oe,
            'fnx.pd.order',
            domain=[('order_no','in',[ono for ono in fis_orders if ono not in oe_orders])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set',
                'dept', 'coating', 'allergens',
                ],
            context={'active_test': False},
        ):
        oe_orders[order.order_no] = order
    #
    # get a list of all keys, and figure out whats new, what's old, and what's changed
    #
    for order_no in sorted(list(set(oe_orders.keys() + fis_orders.keys()))):
        old_record = oe_orders.get(order_no)
        new_record = fis_orders.get(order_no)
        if old_record is None:
            # add record
            added_records[order_no] = new_record
            continue
        # if record is already done, ignore any changes
        elif old_record.state in ('complete','cancelled'):
            continue
        elif new_record is None:
            # remove record
            deleted_records[order_no] = old_record
            continue
        # update fis record with OpenERP specific data (applies to both new and changed records)
        new_record.id = old_record.id
        new_record.state = old_record.state
        new_record.line_id_set = old_record.line_id_set
        new_record.schedule_date_set = old_record.schedule_date_set
        if not new_record.confirmed:
            new_record.confirmed = old_record.confirmed
        if new_record.line_id_set:
            new_record.line_id = old_record.line_id
        if new_record.schedule_date_set:
            new_record.schedule_date = old_record.schedule_date
        if new_record == old_record:
            # no changes, move on to next record
            continue
        new_changed_records[order_no] = new_record
        old_changed_records[order_no] = old_record
    #
    # add new orders
    #
    for order_no, order in ProgressView(
            iterable=sorted(added_records.items()),
            message='adding new records',
            view_type=VIEW_TYPE,
        ):
        added_count += 1
        if LIST_RECORDS:
            echo('  QALL:%-10s  %s' % (order.order_no, order.item_id.name))
            print('     --> ', repr(order), verbose=2)
            echo()
        if not DRYRUN:
            product_orders.create(order_no, order)
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_records, new_changed_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        order_nos = [r.order_no for r in records]
        oe_ids = [r.id for r in records]
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  QALL:%-10s  %s' % (rec.order_no, rec.item_id.name)))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            product_orders.write('|'.join(order_nos), oe_ids, values, context={})
    #
    # deleted/deactivate orders
    #
    for _ in ProgressView(
            iterable=(True, ),
            message='removing irrelevent records',
            view_type=VIEW_TYPE,
        ):
        ## get the ids of actually existing records
        ids = [rec.id for key, rec in deleted_records.items()]
        if ids:
            deleted_count = len(ids)
            if deleted_count:
                if LIST_RECORDS:
                    for order_no, rec in sorted(deleted_records.items()):
                        echo('  QALL:%-10s  %s' % (order_no, rec.item_id.name))
                if not DRYRUN:
                    product_orders.delete(ids, context=context)
    #
    print('%d orders changed\n%d orders added\n%d orders removed'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def convert_spreadsheet(file_name):
    'convert records on 21-day tab into schedule records'
    print('processing %s' % file_name)
    #
    # get spreadsheet data
    #
    orders = {}
    sheet_data = []
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            sheet_data.append(tuple([c.strip() for c in row]))
    #
    oe_products = dict([
        (r.xml_id, Many2One(r.id, r.name))
        for r in get_records(
            oe, 'product.product',
            domain=[('module','=','F135')],
            fields=['id','xml_id','name'],
            context={'active_test': False},
        )])
    line_ids = {}
    oe_production_lines = {}
    for line in get_records(
            oe,
            'fis_integration.production_line',
            fields=['id','xml_id','name'],
        ):
        line_ids[line.id] = line
        oe_production_lines[line.xml_id] = [Many2One(line.id, line.name)]
    for multiline in Query(
            oe.get_model('fnx.pd.multiline'),
            fields=['id', 'key', 'line_ids/line_id'],
        ):
        lines = []
        for ml in multiline.line_ids:
            lines.append(ml.line_id)
        oe_production_lines[multiline.key] = lines
    #
    print('%d lines in sheet' % (len(sheet_data), ))
    for i, row in enumerate(sheet_data, start=2):
        last_row = None
        if row == last_row:
            continue
        try:
            last_row = row
            order = AttrDict()
            # add order number and line id last, as this may be a multiline setup
            id_num = row[ORDER_NUM]
            print('  processing row %d, order %s' % (i, id_num), verbose=3)
            # order.user = row[EMAIL]
            order.dept = row[DEPT]
            order.item_id = oe_products[row[ITEM_CODE]]
            # order.desc= row[ITEM_DESC]
            order.confirmed = (False, 'fis')[row[CONFIRMED] == 'Y']
            order.ordered_qty = float(row[QTY].strip() or 0)
            order.schedule_date = fix_date(row[DATE], format='ymd')
            order.day = Weekday.from_abbr(row[DAY])
            order.coating = row[COATING]
            order.allergens = row[ALLERGENS]
            #
            line = row[PROD_LINE]
            line = ('0' + line)[-2:]
            lines = oe_production_lines[line]
            if len(lines) == 1:
                # simple case, just the one order step
                [line] = lines
                order.order_no = id_num
                order.line_id = line
                orders[id_num] = order
            else:
                # multiple steps: make a copy for each one
                total = len(lines)
                for i, line_step in enumerate(lines, start=1):
                    num_step = "%s-%d_%d" % (id_num, i, total)
                    order_step = order.copy()
                    order_step.order_no = num_step
                    order_step.line_id = line_step
                    orders[num_step] = order_step
        except Exception as exc:
            error('unable to process row %d: %r\n%r' % (i, row, exc))
            continue
    return orders

StatusCode = {
        'New': 'draft',
        'Scheduled': 'sequenced',
        'Released': 'released',
        'Running': 'running',
        'Stopped': 'stopped',
        'Complete': 'complete',
        'Cancelled': 'cancelled',
        }

with user_ids(0, 0):
	Main()
