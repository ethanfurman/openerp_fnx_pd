#!/usr/bin/env python
from __future__ import print_function

from math import ceil
from scription import *
from syslog import syslog
from VSS import Date, fix_date
from VSS.BBxXlate import fisData
from VSS.path import Path
from VSS.utils import ProgressBar, Enum, IntEnum, AutoEnum, IndexEnum, Weekday
from VSS.xl import open_workbook
from openerplib import AttrDict, get_connection, get_records
from openerp.addons.fnx import SortedDocEnum
import shutil
import time

SOURCE = Path('/var/fis/production/')
ARCHIVE = Path('/var/openerp/archive/production/')
ERRORS = Path('/var/openerp/archive/production/error')
USER_PW_DB = Path('/etc/openerp/credentials')

execfile(USER_PW_DB)


@Command(
        values=('settings to use', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def manual_update(hostname='localhost', db=DB, login=USER, password=None, **values):
    if password is None:
        password = PW
    OE = connect(hostname, db, login, password)
    pass

@Command(
        file_to_process=('order to add/update in system', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def process(file_to_process='', hostname='localhost', db=DB, login=USER, password=None):
    "imports a production spreadsheet into FnxPd"
    if password is None:
        password = PW
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    OE = connect(hostname, db, login, password)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    retry = []
    failed = []
    for group in ((files, failed), ):
        time.sleep(5)
        trying, failing = group
        for file in trying:
            errors = import_spreadsheet(OE, file)
            if errors:
                [fnxpd_manager] = get_records(OE.conn, 'ir.model.data', domain=[('module','=','fnx_pd'),('model','=','res.groups'),('name','=','group_fnx_pd_manager')])
                [fnxpd_manager_group] = get_records(OE.conn, 'res.groups', domain=[('id','=',fnxpd_manager.res_id)])
                managers = get_records(OE.conn, 'res.users', domain=[('id','=',fnxpd_manager_group.users)], fields=['id','login','email'])
                emails = [mgr.email for mgr in managers if mgr.id != 1]
                mail_errors = mail('mail.sunridgefarms.com', 25, process_failure_mail % (', '.join(emails), '\n'.join(errors)))
                if mail_errors:
                    print('unable to mail: ', mail_errors.items(), sep='\n   ', file=stderr)
                raise SystemExit("errors during processing, mail attempted")
    if failed:
        raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))

module = globals()

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

ProductionState = IntEnum(
    'ProductionState',
    'draft needy partial scheduled ready running complete cancelled',
    )
module.update(ProductionState.__members__)

QAll_C = IndexEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )
module.update(QAll_C.__members__)

class BadFormat(Exception):
    "production order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

# more values to know about
class FISenum(str, Enum):
    pass

class F320(str, Enum):
    """
    IFMS - FORMULA MASTER FILE
    """
    company_id            = 'An$(1,2)'       # Company Code
    formula_id            = 'An$(3,10)'      # Formula Code
    rev_id                = 'An$(15,3)'      # Revision Number
    desc                  = 'Bn$'            # Description
    coating               = 'Cn$'            # Project Number (mis-named)
    dept_id               = 'En$(13,2)'      # Department Code
    color                 = 'En$(15,20)'     # Color
    formulated_by         = 'Fn$(1,3)'       # Formulated By
    formula_type          = 'Fn$(4,1)'       # Formula Type
    ok_to_use             = 'Fn$(5,1)'       # Ok To Use?
    bulk_item_id          = 'Fn$(18,6)'      # Bulk Item Code
    prod_units            = 'Fn$(26,2)'      # Production Units
    allergens             = 'Fn$(28,8)'      # Alpha Sort Key (mis-named)

class F328(str, Enum):
    """
    IFPP0 - SALES ORDER PRODUCTION PENDING - HEADER
    """
    company_id              = 'An$(1,2)'        # Company Code
    order_id                = 'An$(3,6)'        # Order Number
    produced                = 'Bn$(8,1)'        # Produced (Y/N/P/X)
    order_confirmed         = 'Bn$(13,1)'       # Order Confirmed?
    prod_id                 = 'Cn$(1,8)'        # Product Number
    formula_id              = 'Cn$(19,10)'      # Formula Code
    formula_rev             = 'Cn$(29,3)'       # Formula Revision
    dept_id                 = 'Cn$(157,2)'      # Department Code
    prod_line               = 'Cn$(159,2)'      # Production Line
    units_produced          = 'Ln'              # Units Produced
    no_of_lots_produced     = 'Mn'              # No Of Lots Produced
    qty_on_order            = 'Nn'              # Qty On Order

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def connect(hostname, database, user, password):
    OE = AttrDict()
    print('connecting to %s:%s' % (hostname, database))
    OE.conn = conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    return OE

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    return AttrDict(g['order'])

# production date, production line should not be updated from QALL once they have been changed in OpenERP
def import_spreadsheet(OE, file_name):
    fis_f320 = fisData.fisData(320, keymatch='10%s      %s0')
    fis_f328 = fisData.fisData(328, keymatch='10%s000010000')
    errors = []
    imported_orders = []    # list of imported current orders so that non-current orders still on file can be flagged completed/cancelled
    completed_orders = []   # list of orders that are marked completed in FIS
    line_ids = AttrDict(
            (r.xml_id, r) for r in get_records(
                OE.conn,
                'fis_integration.production_line',
                fields=['id','xml_id'],
            ))
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        last_row = None
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            if row == last_row:
                continue
            order_num = row[ORDER_NUM]
            print('processing row %d, order %s' % (i, order_num), verbose=2)
            followers = get_records(OE.conn, 'res.users', fields=['id'], domain=[('login','=',row[EMAIL])], max_qty=1)
            followers = [rec.id for rec in followers] or False
            item = get_records(OE.conn, 'product.product', fields=['id'], domain=[('xml_id','=',row[ITEM_CODE])], max_qty=1)
            if not item:
                # couldn't find the product, record the error
                errors.append('<row %3d> order %s: product %s not found' % (i, order_num, row[ITEM_CODE]))
                print(errors[-1])
                continue
            try:
                fis_row = fis_f328[order_num]
            except KeyError:
                print('  cannot find %s in FIS' % order_num)
                continue
            formula_id_rev = fis_row[F328.formula_id], fis_row[F328.formula_rev]
            formula = fis_f320[formula_id_rev]
            item = item[0].id
            data = AttrDict()
            data.follower_ids = followers
            data.dept = fis_row[F328.dept_id]
            # the value of fis_row[F328.prod_line] should be the textual representation of an integer between '01' and '99'
            try:
                prod_id = '%02d' % int(fis_row[F328.prod_line])
            except ValueError:
                # no product line, record the error
                errors.append('<row %3d> order %s: no product line' % (i, order_num))
                print(errors[-1])
                continue
            data.line_id = line_ids[prod_id].id
            data.item_id = item
            data.order_no = order_num
            data.confirmed = fis_row[F328.order_confirmed] == 'Y'
            try:
                data.qty = int(ceil(float(row[QTY])))
            except ValueError:
                # no quantity, record the error
                errors.append('<row %3d> order %s: no order quantity' % (i, order_num))
                print(errors[-1])
                continue
            try:
                sched_date = fix_date(row[DATE], format='ymd')
            except ValueError:
                sched_date = ''
            if not sched_date:
                # no schedule date, record the error
                errors.append('<row %3d> order %s: missing or invalid schedule date' % (i, order_num))
                print(errors[-1])
                continue
            if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                print('skipping %s: Saturday schedule' % order_num)
                continue
            imported_orders.append(data.order_no)
            data.schedule_date = str(sched_date)
            data.coating = formula[F320.coating]
            data.allergens = formula[F320.allergens]
            current_record = get_records(OE.conn, 'fnx.pd.order', domain=[('order_no','=',data.order_no)], max_qty=1)
            if current_record:
                print('  checking for changed fields', verbose=2)
                del data.follower_ids
                del data.dept
                del data.order_no
                current_record = current_record[0]
                if (
                        data.qty != current_record.qty or
                        data.coating != current_record.coating or
                        data.allergens != current_record.allergens or
                        data.confirmed != current_record.confirmed or
                        data.line_id != current_record.line_id[0]
                    ):
                    print('updating %s' % row[ORDER_NUM])
                    for key in data:
                        if key == 'schedule_date':
                            continue
                        elif key == 'item_id':
                            if data[key] != current_record[key][0]:
                                print('  %s: %r -> %r' % (key, current_record[key], data[key]))
                        elif data[key] != current_record[key]:
                            print('  %s: %r -> %r' % (key, current_record[key], data[key]))
                    OE.fnx_pd_order.write(current_record.id, dict(data))
            else:
                if not data.follower_ids:
                    del data.follower_ids
                print('creating %s' % row[ORDER_NUM], 'with:\n', data)
                OE.fnx_pd_order.create(dict(data))
    oe_open_orders = get_records(
            OE.conn,
            'fnx.pd.order',
            fields=['id', 'order_no'],
            domain=[('order_no','not in',imported_orders),('state','not in',['complete','cancelled'])],
            )
    print('checking open orders in OE')
    for open_order in oe_open_orders:
        values = {}
        try:
            fis_order = fis_f328[open_order.order_no]
        except KeyError:
            status = 'N'
        else:
            status = fis_order[F328.produced]
        if status == 'Y':
            state = 'complete'
        elif status == 'X':
            state = 'cancelled'
        elif status in 'P N':
            # no action
            continue
        else:
            # unknown, skip until tomorrow and hope somebody fixes it
            print('order %s: unknown status %r' % (open_order.order_no, fis_order[F328.produced]))
            continue
        values['state'] = state
        if state == 'complete':
            values['completed_fis_qty'] = fis_order[F328.units_produced]
        print('updating %s: %s' % (open_order.order_no, values))
        OE.fnx_pd_order.write([open_order.id], values)
    return errors


def update_order(values):
    pass


process_failure_mail = """\
To: %s
From: FnxPD <noreply@sunridgefarms.com>
Subject: Failures during processing of QALL spreadsheet

The following errors were detected during nightly processing:

%s
"""

Main()
