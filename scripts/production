#!/usr/local/sbin/suid-python --virtualenv
# imports
from __future__ import print_function

from antipathy import Path
import sys

import email
import os
import shutil
import time
from dbf import Date, Time, DateTime
from openerplib import AttrDict, get_connection, get_records
from openerplib.dates import LOCAL_TIME, date_to_str, datetime_to_str
from scription import *
from updates.fis_schema import F135, F320, F328, F329
from VSS.constants import IndexEnum, Weekday
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_date
from VSS.xl import open_workbook
from traceback import format_exception
from xmlrpclib import Fault

VIRTUAL_ENV = os.environ['VIRTUAL_ENV']
SOURCE = Path('%s/var/fis/production/' % VIRTUAL_ENV)
ARCHIVE = Path('%s/var/openerp/archive/production/' % VIRTUAL_ENV)
ERRORS = Path('%s/var/openerp/archive/production/error' % VIRTUAL_ENV)
CONFIG = OrmFile('%s/config/fnx.ini' % VIRTUAL_ENV, section='openerp')

Q = QAll_C = IndexEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )

process_failure_mail = """\
To: %s
From: FnxPD <noreply@sunridgefarms.com>
Date: %s
Subject: Failures during processing of QALL spreadsheet

The following errors were detected during nightly processing:

%s
"""


# API

global OE

@Command(
        table=Spec('which table to update', REQUIRED, choices=['product','production']),
        ids=Spec('ids of records to change', REQUIRED),
        values=Spec('settings to use', REQUIRED),
        )
def manual_update(table, ids, **values):
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    ids = [int(i) for i in ids.replace(',',' ').split()]
    for key, value in values.items():
        for t in (int, float):
            try:
                value = t(value)
                break
            except ValueError:
                pass
    table = OE.conn.get_model({'product':'product.product', 'production':'fnx_pd.production'}[table])
    table.write(ids, values)

@Command(
        file_to_process=('order to add/update in system', ),
        order=('specific order number from file to process', ),
        dryrun=('do not update tables', FLAG),
        )
def process(file_to_process='', order='', dryrun=False):
    "imports a production spreadsheet into FnxPd"
    if file_to_process:
        files = [file_to_process]
    else:
        files = [f for f in get_files() if f.ext == '.xls']
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    OE.fnx_pd_ingredient = OE.conn.get_model('fnx.pd.ingredient')
    OE.product = OE.conn.get_model('product.product')
    print('getting inventory...')
    OE.inventory = dict([
        (r.xml_id, r.id)
        for r in get_records(
                OE.conn,
                'product.product',
                fields=['id', 'xml_id'],
                domain=[('module','=','F135')],
                )])
    print('getting orders...')
    OE.orders = dict([
        (r.order_no, r)
        for r in get_records(
                OE.conn,
                'fnx.pd.order',
                )])
    print('getting ingredients...')
    OE.ingredients = dict([
        (r.name, r)
        for r in get_records(
                OE.conn,
                'fnx.pd.ingredient',
                fields=['id', 'name', 'order_id', 'order_no', 'item_id', 'qty_needed', 'qty_desc'],
                )])
    for file in files:
        print('using file:', file)
        imported_orders, errors = import_spreadsheet(file, order or None, dryrun=dryrun)
        if not order:
            check_open_orders(dryrun=dryrun)
        if errors:
            if CONFIG.db.startswith('test') or dryrun:
                # do not send mail from test machines nor during dry runs
                abort('errors during processing')
            [fnxpd_manager] = get_records(
                    OE.conn,
                    'ir.model.data',
                    domain=[('module','=','fnx_pd'),('model','=','res.groups'),('name','=','group_fnx_pd_manager')],
                    )
            [fnxpd_manager_group] = get_records(
                    OE.conn,
                    'res.groups',
                    domain=[('id','=',fnxpd_manager.res_id)],
                    )
            managers = get_records(
                    OE.conn,
                    'res.users',
                    domain=[('id','in',fnxpd_manager_group.users)],
                    fields=['id','login','email'],
                    )
            emails = [mgr.email for mgr in managers if mgr.id != 1 and mgr.email]
            if emails:
                print('-------', file=stderr)
                print('sending to: ', ', '.join(emails), file=stderr)
                mail_errors = mail(
                    'mail.sunridgefarms.com',
                    25,
                    process_failure_mail % (
                        ', '.join(emails),
                        email.utils.formatdate(email.utils.mktime_tz(time.localtime()+(None,))),
                        '\n'.join(errors),
                        )
                    )
                if mail_errors:
                    print('unable to mail: ', mail_errors.items(), sep='\n   ', file=stderr)
                raise SystemExit("errors during processing, mail attempted")
            else:
                raise SystemExit("errors during processing")

@Command(
        dryrun=('do not update tables', FLAG),
        )
def open_orders(dryrun=False):
    "check open orders and close if necessary"
    connect(CONFIG.host, CONFIG.db, CONFIG.user, CONFIG.pw)
    OE.fnx_pd_order = OE.conn.get_model('fnx.pd.order')
    check_open_orders(dryrun=dryrun)

# helpers

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

ignored_ingredients = set([
        # nutritional info
        '910000', '910001', '910002', '910003', '910004', '910005', '910006',
        '910007', '910008',
        # misc
        '900110', '900111', '900112', '900113', '900115', '900200', '900205',
        '900210', '900215', '900230', '900235', '900291', '900448', '900485',
        '900700', '900715', '900900', '900910', '900915', '900917', '900918',
        '900920', '900921', '900922', '900930', '900932', '900935', '900940',
        '900950', '900951', '900952', '900954', '900960', '900962', '900965',
        '900970', '900975', '900980', '900983', '900985', '900986', '900995',
        '901000', '901005', '901006', '901008', '901009', '901010', '901011',
        '901012', '901013', '901014', '901019', '901021', '901023', '901028',
        '901031', '901040', '901041', '901042', '901043', '901044', '901045',
        '901046', '901050', '901065', '901091', '901093', '901095', '901097',
        '901098', '901100', '901101', '901102', '901105', '901107', '901111',
        '901112', '901113', '901117', '901128', '901130', '901131', '901132',
        '901133', '901134', '901135', '901200', '901210', '901245', '901265',
        '901279', '901285', '901286', '901288', '901291', '901292', '901293',
        '901295', '901298', '901302', '901315', '901327', '901329', '901331',
        '901338', '901340', '901352', '901370', '901372', '901375', '901380',
        '901400', '901401', '901403', '901404', '901406', '901407', '901409',
        '901425', '901451', '901465', '901467', '901468', '901469', '901500',
        '901502', '901505', '901507', '901510', '901520', '901521', '901522',
        '901523', '901524', '901525', '901530', '901531', '901532', '901533',
        '901570', '901571', '901572', '901630', '902002', '902003', '902004',
        '902005', '902006', '902007', '902008', '902022', '902025', '902027',
        '902071', '902073', '902076', '902078', '902101', '902105', '902120',
        '902125', '902126', '902127', '902128', '902130', '902134', '902136',
        '902140', '902143', '902150', '902152', '902280', '902281', '902282',
        '902283', '902288', '902495', '902498', '902499', '902500', '902501',
        '902502', '902503', '902663', '904108', '905001', '905005', '905008',
        '905010', '905015', '905016', '905685', '905700', '905703', '905728',
        '906017', '906050', '906063', '906212', '906220', '906223', '906225',
        '906704', '906705', '906706', '906707', '907134', '907135', '907149',
        '909450', '910103', '910109', '913810', '914108', '916105', '916107',
        '919163', '919164', '919165', '919180', '921112', '921113', '921115',
        '921117', '921120', '921121', '921122', '921123', '921124', '921125',
        '921126', '921127', '921128', '921129', '921130', '921132', '921133',
        '921138', '921211', '921212', '921300', '921308', '921310', '921312',
        '921313', '921314', '921315', '921320', '921322', '921325', '921330',
        '921335', '921336', '921337', '921338', '921340', '921342', '921345',
        '922162', '922166', '922167', '922600', '922601', '922602', '922603',
        '922604', '922605', '922606', '922607', '922608', '922609', '922610',
        '922611', '922612', '922613', '922614', '922615', '922616', '922617',
        '922618', '923610', '923613', '923614', '923615', '923616', '923617',
        '923618', '923619', '923621', '923622', '929340', '929450', '929550',
        '929551', '929552', '929553', '929610', '936148', '936149', '936150',
        '936151', '936152', '936153', '936154', '939105', '940105', '940200',
        '940201', '940202', '940205', '940210', '940215', '940220', '940225',
        '949448', '949495', '949555', '950800', '950808', '950815', '950817',
        '950820', '950830', '950831', '950832', '950834', '950837', '950925',
        '950926', '950927', '950929', '961005', '961007', '967005', '967052',
        '968103', '968107', '969025', '969027', '969031', '970000', '970150',
        '970220', '970221', '971050', '971051', '971052', '981040', '981095',
        '981097', '981112', '981312', '981400', '985002', '985003', '985103',
        '986063', '986064', '986065', '986066', '986067', '986700', '990103',
        '990605', '995000', '995100', '999016', '999017', '999018',
        # freight charges
        '967001', '967003', '967004', '993030', '993040', '996000', '996001',
        '996002', '996333', '996555', '997090',
        ])


def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def connect(hostname, database, user, password):
    global OE
    OE = AttrDict()
    print('connecting to %s:%s' % (hostname, database))
    OE.conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    return OE

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def get_order(order):
    g = {}
    execfile(order, g)
    return AttrDict(g['order'])

def import_spreadsheet(file_name, only_order_no, dryrun):
    '''
    add/update orders from spreadsheet; also add as-yet-unreferenced formulai
    '''
    # production date, production line should not be updated from QALL once
    # they have been changed in OpenERP
    global fis_f135, fis_f320, fis_f328, fis_f329
    fis_f135 = fisData('NVTY1', keymatch="%s101000    101**")   # NVTY
    fis_f320 = fisData(320, keymatch='10%s  %s0')               # IFMS
    fis_f328 = fisData(328, keymatch='10%s000010000')           # IFPP0
    fis_f329 = fisData('IFPP1', subset="10%s")                  # IFPP1
    errors = []
    # list of imported current orders so that non-current orders still on file
    # can be flagged completed/cancelled
    imported_orders = []
    line_ids = dict(
            (r.xml_id, r) for r in get_records(
                OE.conn,
                'fis_integration.production_line',
                fields=['id','xml_id'],
            ))
    today = Date.today()
    # get current orders and construct a dict of (schedule_date, min(sequence))
    multilines = dict([(r.key, r.line_ids) for r in get_records(OE.conn, 'fnx.pd.multiline', fields=['key', 'line_ids'])])
    multistep = {}
    for key, multiline in multilines.items():
        lines = get_records(OE.conn, 'fnx.pd.multiline.entry', ids=multiline, fields=['line_id'])
        ids = [l.line_id[0] for l in lines]
        sequence = [(i, l.line_id[0]) for i, l in enumerate(lines)]
        xml_ids_map = dict([(x.id, x) for x in get_records(OE.conn, 'fis_integration.production_line', ids=ids, fields=['xml_id'])])
        xml_ids = []
        for seq, xid in sequence:
            xml_ids.append(xml_ids_map[xid])
        multistep[key] = [r.xml_id for r in xml_ids]
    for key, lines in multistep.items():
        print(key, lines, verbose=2)
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        last_row = None
        rows = list(sheet.rows(start_row=1))
        print('processing %d rows' % len(rows))
        for i, row in enumerate(rows, start=1):
            try:
                # try to bail early: closed order and date older than three months?
                order_num = row[Q.ORDER_NUM]
                # print('\n%9s' % order_num, end='  ')
                try:
                    sched_date = fix_date(row[Q.DATE], format='ymd')
                except ValueError:
                    sched_date = ''
                # print('%15s' % sched_date, end='')
                if row == last_row:
                    # print('=', end='')
                    continue
                data = AttrDict()
                if only_order_no and order_num != only_order_no:
                    continue
                print('  processing row %d, order %s' % (i, order_num), verbose=2)
                item = OE.inventory.get(row[Q.ITEM_CODE])
                if not item:
                    # couldn't find the product, record the error
                    errors.append(
                            '<row %3d> order %s: product %s not found'
                                % (i, order_num, row[Q.ITEM_CODE]),
                            )
                    # error(' ', errors[-1])
                    # print('p', end='')
                    continue
                try:
                    fis_row = fis_f328[order_num]
                except KeyError:
                    errors.append('  cannot find %s in FIS' % order_num)
                    # error(' ', errors[-1])
                    # print('f', end='')
                    continue
                data.dept = fis_row[F328.dept_id]
                # the value of fis_row[F328.prod_line] should be the textual
                # representation of an integer between '01' and '99' for a simple order,
                # or an alphabetic code representing a range of lines in a compound order
                try:
                    line = fis_row[F328.prod_line]
                    print('    line is', line, verbose=2)
                    if line.isdigit():
                        # an error here causes us to default to line 98
                        prodline_id = '%02d' % int(fis_row[F328.prod_line])
                        if prodline_id not in line_ids:
                            errors.append(
                                    '<row %3d> order %s: line_id %r does not exist (using 98)'
                                        % (i, order_num, prodline_id),
                                    )
                            error(' ', errors[-1])
                            prodline_id = '98'
                        prodline_ids = [prodline_id]
                    elif line.isalpha():
                        # an error here causes us to skip the line
                        prodline_ids = multistep[line]
                    else:
                        raise ValueError()
                except ValueError:
                    # no product line, record the error
                    errors.append('<row %3d> order %s: no, or bad, product line <%r> (using 98)' % (i, order_num, line))
                    error(' ', errors[-1])
                    prodline_ids = ['98']
                print('    prodline_ids:', prodline_ids, verbose=2)
                steps = len(prodline_ids)
                print('    steps:', steps, verbose=2)
                for step, prodline in enumerate(prodline_ids, start=1):
                    data.line_id = line_ids[prodline].id
                    data.item_id = item
                    data.order_no = order_num
                    if steps > 1:
                        data.order_no += '-%d_%d' % (step, steps)
                    print('    data.order_no:', data.order_no, verbose=2)
                    current_oe_order = OE.orders.get(data.order_no)
                    if current_oe_order:
                        if 'state' not in current_oe_order:
                            error('missing state field')
                            abort(current_oe_order)
                        elif current_oe_order.state in ('complete','cancelled'):
                            # print('s', end='')
                            continue
                    data.confirmed = (False, 'fis')[fis_row[F328.order_confirmed] == 'Y']
                    data.ordered_qty = fis_row[F328.qty_on_order]
                    if not sched_date:
                        # no schedule date, record the error
                        errors.append(
                                '<row %3d> order %s: missing or invalid schedule date'
                                    % (i, order_num),
                                )
                        error(' ', errors[-1])
                        data.schedule_date = False
                    else:
                        data.schedule_date = date_to_str(sched_date)
                    data.completed_fis_qty = fis_row[F328.units_produced] or False
                    if data.completed_fis_qty:
                        data.finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
                        if data.finish_date:
                            finish_datetime = DateTime.combine(data.finish_date, Time(17, 0, 0)).datetime()
                            data.finish_date = datetime_to_str(
                                    LOCAL_TIME.normalize(
                                        LOCAL_TIME.localize(finish_datetime)
                                    ))
                    else:
                        data.finish_date = False
                    imported_orders.append(data.order_no)
                    if current_oe_order:
                        print('      checking for changed fields', verbose=2)
                        if not dryrun:
                            pass
                            # update_formula(order_num, data, errors)
                        for k in data.keys():
                            if k == 'order_no':
                                # TODO: remove this if once all orders have the order id attached
                                continue
                            if k.endswith('_id'):
                                if data[k] == current_oe_order[k][0]:
                                    del data[k]
                            elif data[k] == current_oe_order[k]:
                                try:
                                    old_values = data._values.copy()
                                    old_keys = data._keys[:]
                                    del data[k]
                                except ValueError:
                                    print('FAILURE', k)
                                    print(old_values)
                                    print(old_keys)
                                    raise
                        if data:
                            if sched_date:
                                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                                    print('deleting %s: Saturday schedule' % order_num, verbose=2)
                                    if not dryrun:
                                        OE.fnx_pd_order.unlink(current_oe_order.id, context={'script': True})
                                    continue
                                elif (sched_date - today).days > 21:
                                    print('deleting %s: more than three weeks out' % order_num, verbose=2)
                                    if not dryrun:
                                        OE.fnx_pd_order.unlink(current_oe_order.id, context={'script': True})
                                    continue
                            print('updating %s' % row[Q.ORDER_NUM], verbose=2)
                            for key in data:
                                if key == 'order_no':
                                    # TODO: remove this if once all orders have the order id attached
                                    continue
                                elif data[key] != current_oe_order[key]:
                                    print('  %s: %r -> %r' % (key, current_oe_order[key], data[key]), verbose=2)
                                else:
                                    print('  oops, forgot to delete key', key, verbose=2)
                            if not dryrun:
                                OE.fnx_pd_order.write(current_oe_order.id, dict(data), context={'script': True})
                    elif sched_date and Weekday.from_date(sched_date) is Weekday.SATURDAY:
                        print('skipping %s: Saturday schedule' % order_num, verbose=2)
                        continue
                    else:
                        if not dryrun:
                            print('creating %s' % row[Q.ORDER_NUM], 'with:\n', data, verbose=2)
                            order_id = OE.fnx_pd_order.create(dict(data), context={'script': True})
                            OE.orders[order_num] = AttrDict(id=order_id)
                            update_formula(order_num, data, errors)
            except Exception:
                lines = format_exception(*sys.exc_info())
                error('skipping %s due to error:' % order_num)
                error(''.join(lines))

    return imported_orders, errors

def check_open_orders(ignore=(), dryrun=False):
    global fis_f328
    fis_f328 = fisData(328, keymatch='10%s000010000')
    today = Date.today()
    oe_open_orders = get_records(
            OE.conn,
            'fnx.pd.order',
            fields=['id', 'completed_fis_qty', 'order_no', 'schedule_date', 'state'],
            domain=[('order_no','not in',ignore),('state','not in',['complete','cancelled'])],
            )
    print('checking %d open orders in OE' % len(oe_open_orders))
    for open_order in oe_open_orders:
        data = AttrDict()
        print('   order %s' % open_order.order_no, end=' --> ', verbose=2)
        try:
            order_no = open_order.order_no.split('-')[0]
            fis_row = fis_f328[order_no]
        except KeyError:
            # no longer present, delete
            print('deleting missing order: %s' % open_order.order_no, verbose=2)
            if not dryrun:
                OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
            continue
        else:
            status = fis_row[F328.produced]
            sched_date = fix_date(fis_row[F328.prod_scheduled_date], format='ymd') or False
            if sched_date:
                if Weekday.from_date(sched_date) is Weekday.SATURDAY:
                    print('deleting %s: Saturday schedule' % open_order.order_no, verbose=2)
                    if not dryrun:
                        OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                elif (sched_date - today).days > 21:
                    print('deleting %s: more than three weeks out' % open_order.order_no, verbose=2)
                    if not dryrun:
                        OE.fnx_pd_order.unlink(open_order.id, context={'script': True})
                    continue
                data.schedule_date = str(sched_date)
            print('  using %r' % sched_date, end=' . . . ', verbose=2)
            finish_date = fix_date(fis_row[F328.prod_date], format='mdy') or False
            if finish_date:
                finish_datetime = DateTime.combine(finish_date, Time(17, 0, 0)).datetime()
                data.finish_date = datetime_to_str(
                        LOCAL_TIME.normalize(
                            LOCAL_TIME.localize(finish_datetime)
                        ))
            qty = fis_row[F328.units_produced] or False
            if qty and qty != open_order.completed_fis_qty:
                data.completed_fis_qty = fis_row[F328.units_produced]
        if status == 'Y':
            state = 'complete'
        elif status == 'X':
            state = 'cancelled'
        elif status in 'P N':
            state = None
        else:
            # unknown, skip until tomorrow and hope somebody fixes it
            print('order %s: unknown status %r'
                    % (open_order.order_no, fis_row[F328.produced]), end=' . . . ',
                    )
            state = None
        if state and state != open_order.state:
            data.state = state
        if data:
            print('updating with: %s' % (dict(data), ), verbose=2)
            if not dryrun:
                OE.fnx_pd_order.write([open_order.id], dict(data), context={'script': True})
        else:
            print()

def update_formula(order_num, data, errors):
    print('        updating formula for', order_num, verbose=2)
    print('          current data:', data, verbose=2)
    sales_header = fis_f328[order_num]
    # pad the formula to 10 chars
    formula_id_rev = '%-10s' % sales_header[F328.formula_id], sales_header[F328.formula_rev]
    formula_header = fis_f320[formula_id_rev]
    # assemble list of ingredients, creating any that are missing
    target_item, ingreds = get_order_ingredients(order_num, include_null=False)
    print('           ingredients:', ingreds, verbose=2)
    ingreds_ids = []
    for item_xml_id, key, rec, _ in ingreds:
        if item_xml_id == target_item:
            continue
        item_id = OE.inventory.get(item_xml_id)
        print('        item id: %r' % (item_id, ), verbose=2)
        print('        item xml id: %r' % (item_xml_id, ), verbose=2)
        if item_id is None:
            try:
                item_id = OE.product.search([('xml_id','=',item_xml_id)])[0]
            except IndexError:
                print('item %r not found' % (item_xml_id, ), verbose=2)
                errors.append('unable to find ingredient %r in order %s' % (item_xml_id, order_num))
                OE.fnx_pd_ingredient.unlink(ingreds_ids)
                ingreds_ids = []
                break
        qty = rec[F329.qty_batch_1]
        um = rec[F329.units_batch_1]
        name = '%s:%s' % (order_num, item_xml_id)
        print('        name:', name, verbose=2)
        ingred = OE.ingredients.get(name)
        if ingred is None:
            try:
                ingred_values = AttrDict(
                        name=name,
                        order_id=OE.orders[order_num].id,
                        item_id=item_id,
                        qty_needed=qty,
                        qty_desc=um,
                        )
                ingred_values.id = OE.fnx_pd_ingredient.create(dict(ingred_values))
                ingred_values.order_no = order_num
                OE.ingredients[name] = ingred_values
                ingreds_ids.append(ingred_values.id)
            except Fault as exc:
                error('error creating %r --> %s' % (name, exc.faultCode.replace('\n\n', ':  ')))
                continue
        else:
            # check that the important bits match
            ingredient = AttrDict()
            if ingred.order_id != OE.orders[order_num].id:
                ingredient.order_id = OE.orders[order_num].id
            if ingred.item_id != item_id:
                ingredient.item_id = item_id
            if ingred.qty_needed != qty:
                ingredient.qty_needed = qty
            if ingred.qty_desc != um:
                ingredient.qty_desc = um
            if ingredient:
                OE.fnx_pd_ingredient.write(ingred.id, dict(ingredient))
            ingreds_ids.append(ingred.id)
    remove_ingreds_ids = [
            i.id
            for i in OE.ingredients.values()
            if i.order_no == order_num and i.id not in ingreds_ids
            ]
    if remove_ingreds_ids:
        OE.fnx_pd_ingredient.unlink(remove_ingreds_ids)
    if ingreds_ids:
        data.ingredient_ids = [(6, 0, ingreds_ids)]
    # add the formula details
    data.formula_code ='%s [%s-%s]' % (formula_header[F320.desc], formula_id_rev[0].strip(), formula_id_rev[1])
    data.coating = formula_header[F320.coating]
    data.allergens = formula_header[F320.allergens]

def update_order(values):
    pass

def get_order_ingredients(order, food_only=False, include_null=True):
    # get the order record from 328
    order, order_no = fis_f328[order], order
    item = order[F328.prod_no].strip()
    # then the ingredients
    fulllist = [(rec[F329.ingr_code_batch_1], key, rec) for key, rec in fis_f329.get_subset(order_no)]
    # import pdb; pdb.set_trace()
    foodlist = []
    for ingredient, key, rec in fulllist:
        ingredient = ingredient[:6]
        if ingredient in ignored_ingredients:
            continue
        if rec[F329.qty_batch_1] or include_null:
            if fis_f135.has_key(ingredient):
                if item == ingredient:
                    foodlist.append((ingredient, key, rec, 1)) # the 1 means don't eplode (isself=1)
                    ingredient = "x" + ingredient # XXX this line should be above the previous one, or removed
                elif not food_only or fis_f135[ingredient][F135.net_un_wt] > 0:
                    # net_un_wt > 0 means it's an item that contributes wght (food ingredient?)
                    foodlist.append((ingredient, key, rec, 0))
    return item, foodlist


Main()
