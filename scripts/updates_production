#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import IntEnum
from antipathy import Path
from dbf import Date, Time, DateTime
from collections import defaultdict
from openerplib import AttrDict, get_connection, get_records, Many2One
from openerplib.dates import date_to_str, datetime_to_str, local_to_utc
from pandaemonium import PidLockFile
from pytz import timezone
from tools import FISenum, combine_by_value, Model, compare_fis_records as get_changed_fis_records
from VSS.BBxXlate.fisData import fisData
from VSS.constants import Weekday
from VSS.finance import FederalHoliday
from VSS.utils import fix_date
from VSS.xl import open_workbook
import os


C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

UTC = timezone('UTC')
with open('/etc/timezone') as tz:
    LTZ = timezone(tz.read().strip())

QAll_C = IntEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )
HEADER, EMAIL, DEPT, PROD_LINE, TYPE, ITEM_CODE, ITEM_DESC, \
    ORDER_NUM, CONFIRMED, QTY, DATE, DAY, COATING, ALLERGENS = QAll_C

# API
@Script(
        dryrun=Spec('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        raise_on_exception=Spec('do not ignore exceptions', FLAG, abbrev=('r', 'raise')),
        )
def main(dryrun, list_records, raise_on_exception):
    global config, oe, errors, DRYRUN, LIST_RECORDS, RAISE_ON_EXCEPTION, VIEW_TYPE, BORDER, script_verbosity
    global ifpp0  # production pending header
    global ifpp1  # production pending detail
    global ifdt   # formula detail, ingredient
    global ifdt1  # formula detail, production info
    global ifms   # formula master
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    if list_records:
        LIST_RECORDS = True
        if not script_verbosity:
            script_verbosity = 1
    RAISE_ON_EXCEPTION = raise_on_exception
    VIEW_TYPE = 'none' if LIST_RECORDS else 'percent'
    BORDER = 'box' if LIST_RECORDS and script_verbosity > 1 else None

@Command(
        files=Spec('old and now files (separated by a comma)', ),
        method=Spec(
            'perform quick or full comparison [quick: compare against old QALL file;'
            ' full: compare against OpenERP records; OpenERP only updated on full]',
            OPTION,
            choices=['quick', 'full'],
            force_default='quick',
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        )
def fnx_pd(method, delete, *files):
    global DELETE, oe_products, oe_production_lines
    DELETE = delete
    files = [f.lower() for f in files]
    print('attempting a %s compare' % method)
    try:
        with PidLockFile('/var/run/fnx_pd_update.pid'):
            oe_products = dict([
                (r.xml_id, Many2One(r.id, r.name))
                for r in get_records(
                    oe, 'product.product',
                    domain=[('module','=','F135')],
                    fields=['id','xml_id','name'],
                    context={'active_test': False},
                )])
            line_ids = {}
            oe_production_lines = {}
            for line in get_records(
                    oe,
                    'fis_integration.production_line',
                    fields=['id','xml_id','name'],
                ):
                line_ids[line.id] = line
                oe_production_lines[line.xml_id] = [Many2One(line.id, line.name)]
            for multiline in get_records(
                    oe,
                    'fnx.pd.multiline',
                    fields=['key', 'line_ids'],
                ):
                lines = []
                for ml in multiline.line_ids:
                    lines.append(Many2One(ml, line_ids[ml].name))
                oe_production_lines[multiline.key] = lines
            #
            if 'ifpp' in files:
                handle_production_order(method)
                handle_production_detail(method)
                files = tuple([f for f in files if f != 'ifpp'])
            if 'ifms' in files:
                handle_product_formula(method)
                files = tuple([f for f in files if f != 'ifms'])
            if 'ifdt' in files:
                handle_product_ingredient(method)
                files = tuple([f for f in files if f != 'ifdt'])
            if method == 'full':
                handle_qall(*files)
    finally:
        for m, problems in sorted(Model.errors.items()):
            error('\n', m, border=('lined', '='), sep='')
            for p in problems:
                error('  ', p)
            error()

@Command(
        old=('file with older order information', ),
        new=('file with newer order information', ),
        order=('individual orders to check', MULTI),
        )
def diff(old, new, order):
    old_qall = convert_spreadsheet(old)
    new_qall = convert_spreadsheet(new)
    new_orders = dead_orders = changed_orders = 0
    for i, order_no in enumerate(sorted(set(old_qall.keys() + new_qall.keys()))):
        if order and order_no not in order:
            continue
        old_order = old_qall.get(order_no)
        new_order = new_qall.get(order_no)
        if old_order == new_order:
            continue
        elif new_order is None:
            dead_orders += 1
            print('deleted order: %s' % order_no)
            continue
        elif old_order is None:
            new_orders += 1
            print('new order: %s' % order_no)
            continue
        changed_orders += 1
        print('changes in order: %s' % order_no)
        for field in ('user','dept','line','item','desc','conf','qty','date','day','coating','allergens'):
            if old_order[field] != new_order[field]:
            #     print('   %s:  %-50r' % (field, old_order[field]))
            # else:
                print('   %s:  %-50s  -->  %s' % (field, old_order[field], new_order[field]))
    print('total orders: %r\ndeleted orders: %r\nnew orders: %r\nchanged orders: %r'
            % (i, dead_orders, new_orders, changed_orders), border='box')


# helpers

def handle_product_formula(method):
    print('processing product formulae (IFMS - 320)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_formula = Model(oe.get_model('fnx.pd.product.formula'), 'ifms', 'F320', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_formula_records = {}
    old_formula_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_formula_records = {}
    new_changed_formula_records = {}
    # these are for added/deleted records
    added_formula_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    # ifpp0 = fisData(328, keymatch='10%s')
    # ifpp1 = fisData(329, keymatch='10%s')
    # ifdt = fisData(322, keymatch='10%s')
    # ifdt1 = fisData(323, keymatch='10%s')
    ifms = fisData(320, keymatch='10%s')
    # print(ifpp0.filename, verbose=2)
    # print(ifpp1.filename, verbose=2)
    # print(ifdt.filename, verbose=2)
    # print(ifdt1.filename, verbose=2)
    print('%s:  %d records' % (ifms.filename, len(ifms)), verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifms_old = fisData(320, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifms_old.filename, len(ifms_old)), verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifms_old.values(),
                ifms.values(),
                enum_schema=[
                    F320.formula_id, F320.rev_no,
                    F320.desc, F320.coating, F320.allergens,
                    ],
                address_fields=[],
                ignore=lambda r: len(r[F320.formula_id]) != 6,
                )
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            added_formula_records[fis_rec.formula] = convert_ifms_rec(fis_rec)
        for fis_rec in deleted:
            deleted_records[fis_rec.formula] = convert_ifms_rec(fis_rec)
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            formula = old[F320.formula]
            old_formula = convert_ifms_rec(old)
            new_formula = convert_ifms_rec(new)
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_formula != new_formula:
                old_formula_records[formula] = old_formula
                new_formula_records[formula] = new_formula
            assert set(old_changed_formula_records.keys()) == set(new_changed_formula_records.keys()),\
                    "old and new formula records mismatch"
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, the compare against all
        # formulas
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifms.values():
            if len(fis_rec[F320.formula_id]) != 6:
                continue
            rec = convert_ifms_rec(fis_rec)
            all_fis_records[rec.formula] = rec
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.formula, r)
            for r in fnx_pd_formula.read(
                fields=[
                    'id', 'name', 'formula', 'description', 'coating', 'allergens',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for formula in set(all_oe_records.keys() + all_fis_records.keys()):
            old_formula = all_oe_records.get(formula)
            new_formula = all_fis_records.get(formula)
            if old_formula is None:
                added_formula_records[formula] = new_formula
                continue
            elif new_formula is None:
                deleted_records[formula] = old_formula
                continue
            # now normalize records for good comparison
            new_formula.id = old_formula.id
            if old_formula == new_formula:
                continue
            else:
                old_changed_formula_records[formula] = old_formula
                new_changed_formula_records[formula] = new_formula
        assert set(old_changed_formula_records.keys()) == set(new_changed_formula_records.keys()),\
                "old and new formula records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing formulas
    print('adding records')
    formula_names = added_formula_records.keys()
    existing_formulae = [
        f.name
        for f in fnx_pd_formula.read(
                domain=[('formula','in',formula_names)],
                fields=['id','name'],
                )]
    for full_name, formula in added_formula_records.items():
        if full_name in existing_formulae:
            fnx_pd_formula.error('FIS Order F320:%s already exists in OpenERP' % (full_name, ))
            continue
        added_count += 1
        name = formula.name
        if LIST_RECORDS:
            echo('  F320:%s' % name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in formula.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_formula.create(full_name, formula)
    #
    # process deletions, but only for formulas that still exist
    #
    print('removing records')
    formula_names = deleted_records.keys()
    formulas = dict([
        (f.id, f)
        for f in fnx_pd_formula.read(
                domain=[('formula','in',formula_names)],
                fields=['id','formula'],
                )])
    if formulas:
        deleted_count = len(formulas)
        if LIST_RECORDS:
            echo('\n'.join(['  F320:%s' % f.formula for f in formulas.values()]))
        if not DRYRUN:
            fnx_pd_formula.unlink(formulas.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_formula_records, new_changed_formula_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        formulae = [r.formula for r in records]
        oe_ids = fnx_pd_formula.search([('formula','in',formulae)])
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for f in records:
                body.append(('  F135:%s' % (f.formula, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_formula.write('|'.join(formulae), oe_ids, values, context={})
    #
    print('%d formulas changed\n%d formulas added\n%d formulas deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_product_ingredient(method):
    print('processing product formula ingredients (IFDT - 322)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_ingredient = Model(oe.get_model('fnx.pd.product.ingredient'), 'ifdt', 'F322', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_ingredient_records = {}
    old_ingredient_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_ingredient_records = {}
    new_changed_ingredient_records = {}
    # these are for added/deleted records
    added_ingredient_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    # ifpp0 = fisData(328, keymatch='10%s')
    # ifpp1 = fisData(329, keymatch='10%s')
    # ifdt = fisData(322, keymatch='10%s')
    # ifdt1 = fisData(323, keymatch='10%s')
    formulae = dict([
        (f.formula, Many2One(f.id, f.formula))
        for f in get_records(oe, 'fnx.pd.product.formula', fields=['id','formula'])
        ])
    oe_items = dict([
        (i.xml_id, Many2One(i.id, i.xml_id))
        for i in get_records(oe, 'product.product', fields=['id','xml_id'], domain=[('module','=','F135')])
        ])
    ifdt = fisData(322, keymatch='10%s')
    # print(ifpp0.filename, verbose=2)
    # print(ifpp1.filename, verbose=2)
    # print(ifdt.filename, verbose=2)
    # print(ifdt1.filename, verbose=2)
    print('%s:  %d records' % (ifdt.filename, len(ifdt)), verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifdt_old = fisData(322, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifdt_old.filename, len(ifdt_old)), verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifdt_old.values(),
                ifdt.values(),
                enum_schema=[
                    F322.formula_id, F322.rev_no,
                    F322.desc, F322.coating, F322.allergens,
                    ],
                address_fields=[],
                ignore=lambda r: ('%s-%s' % (r[F322.formula_id], r[F322.rev_id]) not in formulae
                                  or r[F322.ingr_id_batch_1] not in oe_items),
                )
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            oe_rec = convert_ifdt_rec(fis_rec)
            added_ingredient_records[oe_rec.name] = oe_rec
        for fis_rec in deleted:
            oe_rec = convert_ifdt_rec(fis_rec)
            deleted_records[oe_rec.name] = oe_rec
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            old_ingredient = convert_ifdt_rec(old)
            new_ingredient = convert_ifdt_rec(new)
            name = old_ingredient.name
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_ingredient == new_ingredient:
                continue
            old_ingredient.formula_id = formulae[old_ingredient.formula_id]
            new_ingredient.formula_id = formulae[new_ingredient.formula_id]
            old_ingredient.ingr_id_batch_1 = oe_items[old_ingredient.ingr_id_batch_1]
            new_ingredient.ingr_id_batch_1 = oe_items[new_ingredient.ingr_id_batch_1]
            old_ingredient_records[name] = old_ingredient
            new_ingredient_records[name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                domain=[('name','in',
                        added_ingredient_records.keys()
                        +deleted_records.keys()
                        +old_ingredient_records.keys()
                        )],
                fields=[
                    'id', 'name', 'formula_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, then compare against all
        # ingredients
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifdt.values():
            if '%s-%s' % (fis_rec[F322.formula_id], fis_rec[F322.rev_id]) not in formulae:
                continue
            if fis_rec[F322.ingr_id_batch_1] not in oe_items:
                continue
            ingredient = convert_ifdt_rec(fis_rec)
            all_fis_records[ingredient.name] = ingredient
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                fields=[
                    'id', 'name', 'formula_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for ingredient_name in set(all_oe_records.keys() + all_fis_records.keys()):
            old_ingredient = all_oe_records.get(ingredient_name)
            new_ingredient = all_fis_records.get(ingredient_name)
            if old_ingredient is None:
                new_ingredient.formula_id = formulae[new_ingredient.formula_id]
                new_ingredient.item_id = oe_items[new_ingredient.item_id]
                added_ingredient_records[ingredient_name] = new_ingredient
                continue
            elif new_ingredient is None:
                deleted_records[ingredient_name] = old_ingredient
                continue
            # now normalize records for good comparison
            new_ingredient.id = old_ingredient.id
            new_ingredient.formula_id = formulae[new_ingredient.formula_id]
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            if old_ingredient == new_ingredient:
                continue
            else:
                old_changed_ingredient_records[ingredient_name] = old_ingredient
                new_changed_ingredient_records[ingredient_name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing ingredients
    print('adding records')
    ingredient_names = added_ingredient_records.keys()
    existing_ingredients = [
        i.name
        for i in fnx_pd_ingredient.read(
                domain=[('name','in',ingredient_names)],
                fields=['id','name'],
                )]
    for full_name, ingredient in added_ingredient_records.items():
        if full_name in existing_ingredients:
            fnx_pd_ingredient.error('FIS Order F322:%s already exists in OpenERP' % (full_name, ))
            continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F322:%s' % full_name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in ingredient.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_ingredient.create(full_name, ingredient)
    #
    # process deletions, but only for ingredients that still exist
    #
    print('removing records')
    ingredient_names = deleted_records.keys()
    ingredients = dict([
        (i.id, i)
        for i in fnx_pd_ingredient.read(
                domain=[('name','in',ingredient_names)],
                fields=['id','name'],
                )])
    if ingredients:
        deleted_count = len(ingredients)
        if LIST_RECORDS:
            echo('\n'.join(['  F322:%s' % i.name for i in ingredients.values()]))
        if not DRYRUN:
            fnx_pd_ingredient.unlink(ingredients.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_ingredient_records, new_changed_ingredient_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        ingredients = [r.name for r in records]
        oe_ids = []
        for rec in records:
            oe_ids.append(all_oe_records[rec.name].id)
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for i in records:
                body.append(('  F135:%s' % (i.name, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_ingredient.write('|'.join(ingredient), oe_ids, values, context={})
    #
    print('%d ingredients changed\n%d ingredients added\n%d ingredients deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_production_order(method):
    global ifms
    print('processing production orders (IFPP0 - 328)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_order = Model(oe.get_model('fnx.pd.order'), 'ifpp0', 'F328', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_order_records = {}
    old_order_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_order_records = {}
    new_changed_order_records = {}
    # these are for added/deleted records
    added_order_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    ifpp0 = fisData(328, keymatch='10%s')
    ifpp1 = fisData(329, keymatch='10%s')
    ifdt = fisData(322, keymatch='10%s')
    ifdt1 = fisData(323, keymatch='10%s')
    ifms = fisData(320, keymatch='10%s')
    print(ifpp0.filename, verbose=2)
    print(ifpp1.filename, verbose=2)
    print(ifdt.filename, verbose=2)
    print(ifdt1.filename, verbose=2)
    print(ifms.filename, verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifpp_old = fisData(328, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(ifpp_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifpp_old.values(),
                ifpp0.values(),
                enum_schema=[
                    F328.order_no, F328.produced, F328.confirmed, F328.prod_id,
                    F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
                    F328.prod_sched_date, F328.prod_date, F328.units_produced,
                    ],
                address_fields=[],
                )
        #
        # and convert the new and deleted records
        #
        print('sorting %d new and %d deleted records' % (len(added), len(deleted)))
        for fis_rec in added:
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                added_order_records[rec.order_no] = add_ac(fis_rec, rec)
        for fis_rec in deleted:
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                deleted_records[rec.order_no] = rec
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting $total changed records',
                view_type=VIEW_TYPE,
            ):
            order_no = old[F328.order_no]
            old_order = convert_ifpp0_rec(old)
            old_order_records[order_no] = old_order
            new_order = convert_ifpp0_rec(new)
            new_order_records[order_no] = new_order
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_order != new_order:
                # split orders up
                old_orders = split_steps(old_order)
                new_orders = split_steps(new_order)
                for order_no in set(old_orders.keys() + new_orders.keys()):
                    old_order = old_orders.get(order_no)
                    new_order = new_orders.get(order_no)
                    if old_order is None:
                        new_order
                        added_order_records[order_no] = new_order
                    elif new_order is None:
                        deleted_records[order_no] = old_order
                    else:
                        old_changed_order_records[order_no] = old_order
                        new_changed_order_records[order_no] = new_order
            assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                    "old and new order records mismatch"
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, the compare against all open
        # orders and closed/cancelled orders referenced by the fis records
        #
        # fis first
        #
        print('getting fis records')
        order_numbers = []
        for fis_rec in ifpp0.values():
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                order_numbers.append(rec.order_no)
                all_fis_records[rec.order_no] = rec
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.order_no, r)
            for r in fnx_pd_order.read(
                domain=[
                    '|',
                    ('order_no','in',order_numbers),
                    ('state','in',['draft','sequenced','released','running','stopped']),
                    ],
                fields=[
                    'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
                    'formula_code', 'dept', 'line_id', 'schedule_date', 'finish_date',
                    'completed_fis_qty', 'line_id_set', 'schedule_date_set', 'state',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for order_no in set(all_oe_records.keys() + all_fis_records.keys()):
            old_order = all_oe_records.get(order_no)
            new_order = all_fis_records.get(order_no)
            if old_order is None:
                added_order_records[order_no] = new_order
                continue
            elif new_order is None:
                if old_order.state not in ('complete', 'cancelled'):
                    deleted_records[order_no] = old_order
                continue
            # now normalize records for good comparison
            new_order.id = old_order.id
            new_order.state = old_order.state
            if old_order.line_id_set:
                new_order.line_id_set = True
                new_order.line_id = old_order.line_id
            if old_order.schedule_date_set:
                new_order.schedule_date_set = True
                new_order.schedule_date = old_order.schedule_date
            if old_order != new_order:
                old_changed_order_records[order_no] = old_order
                new_changed_order_records[order_no] = new_order
        assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                "old and new order records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing orders
    print('adding records')
    order_nos = added_order_records.keys()
    existing_order_nos = [
        o.order_no
        for o in fnx_pd_order.read(
                domain=[('order_no','in',order_nos)],
                fields=['id','order_no'],
                )]
    for order_no, order in added_order_records.items():
        if order_no in existing_order_nos:
            fnx_pd_order.error('FIS Order F328:%s already exists in OpenERP' % (order_no, ))
            continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F328:%s' % order_no, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in order.items()]), end='', verbose=2)
            echo('\n', '- -' * 25)
        if not DRYRUN:
            fnx_pd_order.create(order_no, order)
    #
    # process deletions, but only for orders that still exist
    #
    print('removing records')
    order_nos = deleted_records.keys()
    echo('\n---\n'.join([str(v) for v in deleted_records.values()]), border='box')
    orders = dict([
        (o.id, o)
        for o in fnx_pd_order.read(
                domain=[('order_no','in',order_nos),('state','!=','complete')],
                fields=['id','order_no'],
                )])
    if orders:
        deleted_count = len(orders)
        if LIST_RECORDS:
            echo('\n'.join(['  F328:%s' % o.order_no for o in orders.values()]))
        if not DRYRUN:
            fnx_pd_order.unlink(orders.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_order_records, new_changed_order_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        order_nos = [r.order_no for r in records]
        oe_ids = fnx_pd_order.search([('order_no','in',order_nos)])
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  F135:%s' % (rec.order_no, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_order.write('|'.join(order_nos), oe_ids, values, context={})
    #
    print('%d orders changed\n%d orders added\n%d orders deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_production_detail(method):
    print('processing product formula ingredients (IFPP1 - 329)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_ingredient = Model(oe.get_model('fnx.pd.ingredient'), 'ifpp1', 'F329', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_ingredient_records = {}
    new_changed_ingredient_records = {}
    # these are for added/deleted records
    added_ingredient_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    # ifpp0 = fisData(328, keymatch='10%s')
    # ifpp1 = fisData(329, keymatch='10%s')
    # ifdt = fisData(329, keymatch='10%s')
    # ifdt1 = fisData(323, keymatch='10%s')
    oe_orders = dict([
        (o.order_no, o)
        for o in get_records(oe, 'fnx.pd.order', fields=['id','order_no','state'])
        ])
    oe_items = dict([
        (i.xml_id, Many2One(i.id, i.xml_id))
        for i in get_records(oe, 'product.product', fields=['id','xml_id'], domain=[('module','=','F135')])
        ])
    ifpp1 = fisData(329, keymatch='10%s')
    # print(ifpp0.filename, verbose=2)
    # print(ifpp1.filename, verbose=2)
    # print(ifdt.filename, verbose=2)
    # print(ifdt1.filename, verbose=2)
    print('%s:  %d records' % (ifpp1.filename, len(ifpp1)), verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifpp1_old = fisData(329, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifpp1_old.filename, len(ifpp1_old)), verbose=2)
        print('collecting changed records')
        def ignore_order_detail(rec):
            if rec[F329.item_type_batch_1] == 'M':
                return True
            order_no = rec[F329.order_no]
            if order_no not in oe_orders:
                return False
            if oe_orders[order_no].state in ['complete','cancelled']:
                return True
            return False
        changes, added, deleted = get_changed_fis_records(
                ifpp1_old.values(),
                ifpp1.values(),
                enum_schema=[
                    F329.order_no, F329.ingr_id_batch_1, F329.units_batch_1, F329.qty_batch_1
                    ],
                address_fields=[],
                ignore=ignore_order_detail
                )
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            new_ingredient = convert_ifpp1_rec(fis_rec)
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            added_ingredient_records[new_ingredient.name] = new_ingredient
        for fis_rec in deleted:
            old_ingredient = convert_ifpp1_rec(fis_rec)
            deleted_records[old_ingredient.name] = old_ingredient
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            new_ingredient = convert_ifpp1_rec(new)
            old_ingredient = convert_ifpp1_rec(old)
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_ingredient == new_ingredient:
                continue
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            old_ingredient.item_id = oe_items[old_ingredient.item_id]
            old_ingredient.order_id = oe_orders[old_ingredient.order_id].id
            new_ingredient.order_id = oe_orders[new_ingredient.order_id].id
            old_changed_ingredient_records[old_ingredient.name] = old_ingredient
            new_changed_ingredient_records[new_ingredient.name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                domain=[('name','in',
                        added_ingredient_records.keys()
                        +deleted_records.keys()
                        +old_changed_ingredient_records.keys()
                        )],
                fields=[
                    'id', 'name', 'order_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        # add id to old records
        for old_ingredient in old_changed_ingredient_records.values():
            old_ingredient.id = all_oe_records[old_ingredient.name].id
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, then compare against all
        # ingredients
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifpp1.values():
            if '%s-%s' % (fis_rec[F329.order_no], fis_rec[F329.ingr_id_batch_1]) not in oe_orders:
                continue
            if fis_rec[F329.ingr_id_batch_1] not in oe_items:
                continue
            ingredient = convert_ifpp1_rec(fis_rec)
            all_fis_records[ingredient.name] = ingredient
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                domain=[('name','in',all_fis_records.keys())],
                fields=[
                    'id', 'name', 'order_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for name in set(all_oe_records.keys() + all_fis_records.keys()):
            old_ingredient = all_oe_records.get(name)
            new_ingredient = all_fis_records.get(name)
            if new_ingredient is None:
                deleted_records[name] = old_ingredient
                continue
            new_ingredient.order_id = oe_orders[new_ingredient.order_id]
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            if old_ingredient is None:
                added_ingredient_records[name] = new_ingredient
                continue
            # now normalize records for good comparison
            new_ingredient.id = old_ingredient.id
            if old_ingredient == new_ingredient:
                continue
            else:
                old_changed_ingredient_records[name] = old_ingredient
                new_changed_ingredient_records[name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing ingredients
    print('adding records')
    for name, ingredient in added_ingredient_records.items():
        if name in all_oe_records:
            fnx_pd_ingredient.error('FIS Order F329:%s already exists in OpenERP' % (name, ))
            continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F329:%s' % name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in ingredient.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_ingredient.create(name, ingredient)
    #
    # process deletions, but only for ingredients that still exist
    #
    print('removing records')
    missing_ingredients = dict([
        (i.name, i)
        for i in all_oe_records.values()
        if i.name in deleted_records
        ])
    if missing_ingredients:
        deleted_count = len(missing_ingredients)
        if LIST_RECORDS:
            echo('\n'.join(['  F329:%s' % i.name for i in missing_ingredients.values()]))
        if not DRYRUN:
            fnx_pd_ingredient.unlink(missing_ingredients.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_ingredient_records, new_changed_ingredient_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        records = list(records)
        oe_ids = [o.id for o in records]
        names = [o.name for o in records]
        assert len(oe_ids)
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for i in records:
                body.append(('  F135:%s' % (i.name, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_ingredient.write(', '.join(names), oe_ids, values, context={})
    #
    print('%d ingredients changed\n%d ingredients added\n%d ingredients deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_qall(*files):
    print('processing QAll', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    if len(files) > 1:
        abort('only one file can be specified (%r)' % (files, ))
    today = Date.today()
    cutoff = FederalHoliday.next_business_day(today, 15)
    if files:
        [qall] = files
    else:
        # see if today's qall file exists
        qall_files = sorted(config.network.qall.glob(today.strftime('%Y-%M-%d_*')))
        if qall_files:
            qall = files[-1]
        else:
            echo(today.strftime('no QALL file found for %Y-%m-%d'), border='box')
            return
    qall = (files or [config.network.qall_file])[0]
    product_orders = Model(oe.get_model('fnx.pd.order'), 'nvty', 'F135', context, RAISE_ON_EXCEPTION)
    # variables used
    added_records = {}
    old_changed_records = {}
    new_changed_records = {}
    deleted_records = {}
    added_count = 0
    deleted_count = 0
    changed_count = 0
    #
    #
    fis_orders = convert_spreadsheet(qall)
    oe_orders = dict(
        (r.order_no, r) for r in get_records(
            oe,
            'fnx.pd.order',
            domain=[('state','in',['draft','sequenced','released','running','stopped'])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set', #'sequence', 'start_date', 'finish_date',
                'dept', 'coating', 'allergens', #'completed_fis_qty', 'formula_code',
                ],
        ))
    #
    # rules for orders (failure means order is deleted from, or not entered into, OpenERP):
    # - cannot be scheduled for Saturday
    # - must be within three weeks of today (15 business days)
    # - must be present in FIS
    #
    # rules for order state:
    # - if state in FIS is
    #   - Y --> complete
    #   - X --> cancelled
    #   - P, N, or Space --> no change
    #   - anything else --> no change, and record invalid state
    #
    # trim any FIS orders that fail the first two criteria
    for order_no, order in list(fis_orders.items()):
        if order.day is Weekday.SATURDAY:
            fis_orders.pop(order_no)
        elif cutoff <= order.schedule_date:
            fis_orders.pop(order_no)
        # no longer need the day field
        del order.day
    #
    # above oe_orders only has active orders; now check for inactive orders -- we do this
    # so we don't try to add an existing order
    #
    for order in get_records(
            oe,
            'fnx.pd.order',
            domain=[('order_no','in',[ono for ono in fis_orders if ono not in oe_orders])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set', #'sequence', 'start_date', 'finish_date',
                'dept', 'coating', 'allergens', #'completed_fis_qty', 'formula_code',
                ],
            context={'active_test': False},
        ):
        oe_orders[order.order_no] = order
    ## convert date
    ## for order in oe_orders.values():
    ##     order.schedule_date = Date.strptime(order.schedule_date, DEFAULT_SERVER_DATE_FORMAT)
    #
    # get a list of all keys, and figure out whats new, what's old, and what's changed
    #
    for order_no in sorted(list(set(oe_orders.keys() + fis_orders.keys()))):
        old_record = oe_orders.get(order_no)
        new_record = fis_orders.get(order_no)
        if old_record is None:
            # add record
            added_records[order_no] = new_record
            continue
        # if record is already done, ignore any changes
        elif old_record.state in ('complete','cancelled'):
            continue
        elif new_record is None:
            # remove record
            deleted_records[order_no] = old_record
            continue
        # update fis record with OpenERP specific data (applies to both new and changed records)
        new_record.id = old_record.id
        new_record.state = old_record.state
        new_record.line_id_set = old_record.line_id_set
        new_record.schedule_date_set = old_record.schedule_date_set
        if not new_record.confirmed:
            new_record.confirmed = old_record.confirmed
        if new_record.line_id_set:
            new_record.line_id = old_record.line_id
        if new_record.schedule_date_set:
            new_record.schedule_date = old_record.schedule_date
        if new_record == old_record:
            # no changes, move on to next record
            continue
        new_changed_records[order_no] = new_record
        old_changed_records[order_no] = old_record
    #
    # add new orders
    #
    for order_no, order in ProgressView(
            iterable=sorted(added_records.items()),
            message='adding new records',
            view_type=VIEW_TYPE,
        ):
        added_count += 1
        if LIST_RECORDS:
            echo('  QALL:%-10s  %s' % (order.order_no, order.item_id.name))
            print('     --> ', repr(order), verbose=2)
            echo()
        if not DRYRUN:
            product_orders.create(order_no, order)
            # order_id = product_orders.create(order_no, order)
            # if order_id:
            #     order.id = order_id
            #     all_oe_records[order_no] = order
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_records, new_changed_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        order_nos = [r.order_no for r in records]
        oe_ids = [r.id for r in records]
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  QALL:%-10s  %s' % (rec.order_no, rec.item_id.name)))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            product_orders.write('|'.join(order_nos), oe_ids, values, context={})
    #
    # deleted/deactivate orders
    #
    for _ in ProgressView(
            iterable=(True, ),
            message='removing irrelevent records',
            view_type=VIEW_TYPE,
        ):
        ## get the ids of actually existing records
        # order_nos = deleted_records.keys()
        # ids = [rec.id for key, rec in all_oe_records.items() if key in order_nos]
        ids = [rec.id for key, rec in deleted_records.items()]
        if ids:
            deleted_count = len(ids)
            if deleted_count:
                if LIST_RECORDS:
                    for order_no, rec in sorted(deleted_records.items()):
                        echo('  QALL:%-10s  %s' % (order_no, rec.item_id.name))
                if not DRYRUN:
                    product_orders.delete(ids, context=context)
    #
    print('%d orders changed\n%d orders added\n%d orders removed'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )



def add_ac(fis_rec, oe_rec):
    "add allergens and coating to rec"
    # rec is in AttrDict format
    # F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
    formula_rev = '%-10s  %-3s0' % (fis_rec[F328.formula_id], fis_rec[F328.formula_rev])
    formula_rec = ifms[formula_rev]
    oe_rec.coating = formula_rec[F320.coating]
    oe_rec.allergens = formula_rec[F320.allergens]
    return oe_rec


def convert_ifdt_rec(fis_rec):
    "product ingredient"
    # convert the record into the following fields:
    #   formula_id, item_id, qty_needed, qty_desc
    #
    # using:
    #   F322.formula_id, F322.rev_id, F322.ingr_id_batch_1, F322.qty_batch_1, F322.units_batch_1
    #
    ingredient = AttrDict()
    ingredient.formula_id = formula = '%s-%s' % (fis_rec[F322.formula_id], fis_rec[F322.rev_id])
    ingredient.item_id = item = fis_rec[F322.ingr_id_batch_1]
    ingredient.name = '%s:%s' % (formula, item)
    ingredient.qty_needed = fis_rec[F322.qty_batch_1]
    ingredient.qty_desc = fis_rec[F322.units_batch_1]
    return ingredient

def convert_ifms_rec(fis_rec):
    "product formula"
    # convert the record into the following fields:
    #   formula, description, coating, allergens
    #
    # using:
    #   F320.formula, F320.rev_no, F320.desc, F320.coating, F320.allergens
    #
    formula = AttrDict()
    formula.name = name = fis_rec[F320.formula_id]
    formula.formula = '%s-%s' % (name, fis_rec[F320.rev_no])
    formula.description = fis_rec[F320.desc]
    formula.coating = fis_rec[F320.coating]
    formula.allergens = fis_rec[F320.allergens]
    return formula

def convert_ifpp0_rec(fis_rec):
    "sales production order"
    # convert the record into the following fields:
    #   id, order_no, completed_fis_qty, confirmed, item_id,
    #   formula_code, dept, line_id,
    #   schedule_date, finish_date, completed_fis_qty,
    #
    # F328.order_no, F328.produced, F328.confirmed, F328.prod_id,
    # F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
    # F328.prod_sched_date, F328.prod_date, F328.units_produced,
    #
    # multiple lines ARE NOT split
    #
    order = AttrDict()
    order.order_no = fis_rec[F328.order_no]
    order.completed_fis_qty = fis_rec[F328.produced]
    order.confirmed = (False, 'fis')[fis_rec[F328.produced] == 'Y']
    order.item_id = oe_products[fis_rec[F328.prod_id]]
    order.formula_code = '[%s-%s] %s' % (
            fis_rec[F328.formula_id].strip(), fis_rec[F328.formula_rev], fis_rec[F328.label_name],
            )
    order.dept = fis_rec[F328.dept_id] or False
    order.line_id = ('0' + fis_rec[F328.prod_line])[-2:]
    order.line_id_set = False
    sched_date = fix_date(fis_rec[F328.prod_sched_date], 'ymd') or False
    if sched_date:
        sched_date = date_to_str(sched_date)
    order.schedule_date = sched_date
    order.schedule_date_set = False
    fin_date = fix_date(fis_rec[F328.prod_date], 'mdy') or False
    if fin_date:
        fin_date = datetime_to_str(local_to_utc(DateTime.combine(fin_date, Time(17))))
    order.finish_date = fin_date
    order.completed_fis_qty = fis_rec[F328.units_produced] or False
    return order

def convert_ifpp1_rec(fis_rec):
    "product ingredient"
    # convert the record into the following fields:
    #   name, order_id, item_id, qty_needed, qty_desc
    #
    # using:
    #   F329.order_no, F329.ingr_id_batch_1, F329.qty_batch_1, F329.units_batch_1
    #
    ingredient = AttrDict()
    ingredient.order_id = order = fis_rec[F329.order_no]
    ingredient.item_id = item = fis_rec[F329.ingr_id_batch_1]
    ingredient.name = '%s:%s' % (order, item)
    ingredient.qty_needed = fis_rec[F329.qty_batch_1]
    ingredient.qty_desc = fis_rec[F329.units_batch_1]
    return ingredient

def convert_spreadsheet(file_name):
    'convert records on 21-day tab into schedule records'
    print('processing %s' % file_name)
    #
    # get spreadsheet data
    #
    orders = {}
    sheet_data = []
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            sheet_data.append(tuple([c.strip() for c in row]))
    #
    print('%d lines in sheet' % (len(sheet_data), ))
    for i, row in enumerate(sheet_data, start=2):
        last_row = None
        if row == last_row:
            continue
        try:
            last_row = row
            order = AttrDict()
            # add order number and line id last, as this may be a multiline setup
            id_num = row[ORDER_NUM]
            print('  processing row %d, order %s' % (i, id_num), verbose=3)
            # order.user = row[EMAIL]
            order.dept = row[DEPT]
            order.item_id = oe_products[row[ITEM_CODE]]
            # order.desc= row[ITEM_DESC]
            order.confirmed = (False, 'fis')[row[CONFIRMED] == 'Y']
            order.ordered_qty = float(row[QTY].strip() or 0)
            order.schedule_date = fix_date(row[DATE], format='ymd')
            order.day = Weekday.from_abbr(row[DAY])
            order.coating = row[COATING]
            order.allergens = row[ALLERGENS]
            #
            line = row[PROD_LINE]
            line = ('0' + line)[-2:]
            lines = oe_production_lines[line]
            if len(lines) == 1:
                # simple case, just the one order step
                [line] = lines
                order.order_no = id_num
                order.line_id = line
                orders[id_num] = order
            else:
                # multiple steps: make a copy for each one
                total = len(lines)
                for i, line_step in enumerate(lines, start=1):
                    num_step = "%s_%d_%d" % (id_num, i, total)
                    order_step = order.copy()
                    order_step.order_no = num_step
                    order_step.line_id = line_step
                    orders[num_step] = order_step
        except Exception as exc:
            error('unable to process row %d: %r\n%r' % (i, row, exc))
            continue
    return orders

def split_steps(order):
    "return record for each step in line_id"
    if isinstance(order.line_id, Many2One):
        return {order.order_no: order}
    # order is an AttrDict, line_id is a two-character field
    orders = {}
    lines = oe_production_lines[order.line_id]
    if len(lines) == 1:
        # simple case, just the one order step
        [line] = lines
        order.line_id = line
        orders[order.order_no] = order
    else:
        # multiple steps: make a copy for each one
        total = len(lines)
        for i, line_step in enumerate(lines, start=1):
            num_step = "%s_%d_%d" % (order.order_no, i, total)
            order_step = order.copy()
            order_step.order_no = num_step
            order_step.line_id = line_step
            orders[num_step] = order_step
    return orders


# schemas

class F320(FISenum):
    """
    IFMS - FORMULA MASTER FILE
    """
    company_id            = 'An$(1,2)',    0   # Company Code
    formula_id            = 'An$(3,10)',   1   # Formula Code
                                               # (Open) An$(13,2)
    rev_no                = 'An$(15,3)',   3   # Revision Number
    key_type              = 'An$(18,1)',   4   # Key Group = "0"
    desc                  = 'Bn$',         5   # Description
    coating               = 'Cn$',         6   # Project Number (mis-named)
    date_issued           = 'Dn$(1,6)',    7   # Date Issued
    date_revised          = 'Dn$(7,6)',    8   # Date Revised
    date_of_last_run      = 'Dn$(13,6)',   9   # Date Of Last Run
    date_put_on_hold      = 'Dn$(19,6)',  10   # Date Put On Hold
    date_written          = 'Dn$(25,6)',  11   # Date Written
    approved_by           = 'Dn$(31,3)',  12   # Approved By
    changed_by            = 'Dn$(34,3)',  13   # Changed By
    change_approved_by    = 'Dn$(37,3)',  14   # Change Approved By
    date_to_retest        = 'Dn$(40,3)',  15   # Date to Retest
    last_sales_ord        = 'En$(1,6)',   16   # Last Sales Ord. #
    last_cust             = 'En$(7,6)',   17   # Last Customer #
    dept_id               = 'En$(13,2)',  18   # Department Code
    color                 = 'En$(15,20)', 19   # Color
    formulated_by         = 'Fn$(1,3)',   20   # Formulated By
    formula_type          = 'Fn$(4,1)',   21   # Formula Type
    ok_to_use             = 'Fn$(5,1)',   22   # Ok To Use?
    hold_reason           = 'Fn$(6,2)',   23   # Hold Reason
    change_reason_id      = 'Fn$(8,2)',   24   # Change Reason Code
    test_w_milk           = 'Fn$(10,1)',  25   # Test W. Milk?
    tablet_type           = 'Fn$(11,3)',  26   # Tablet Type
    normal_prod_line      = 'Fn$(14,2)',  27   # Normal Production Line
    serving_size_units    = 'Fn$(16,2)',  28   # Serving Size Units
    bulk_item_id          = 'Fn$(18,6)',  29   # Bulk Item Code
                                               # (open) Fn$(24,2)
    prod_units            = 'Fn$(26,2)',  31   # Production Units
    allergens             = 'Fn$(28,8)',  32   # Alpha Sort Key (mis-named)
    std_batch_sizes       = 'Fn$(36,1)',  33   # Std Batch Sizes? (Y/N)
    tube_size             = 'Fn$(37,2)',  34   # Tube Size
                                               # (open) Fn$(39,2)
    label_name            = 'Gn$',        36   # Label Name
    reference_no          = 'Hn$',        37   # Reference No.
    previous_reference_no = 'In$',        38   # Previous Reference No.
    comment_line_1        = 'Jn$',        39   # Comment Line 1
    comment_line_2        = 'Kn$',        40   # Comment Line 2
    serving_size          = 'An',         41   # Serving Size
    expected_yield        = 'Bn',         42   # Expected Yield %
    hardness_range_low    = 'Cn',         43   # Hardness Range - Low
    hardness_range_high   = 'Dn',         44   # Hardness Range - High
    mos_shelf_life        = 'En',         45   # Mos Shelf Life
                                               # (open) Fn
    largest_batch_size    = 'Gn',         47   # Largest Batch Size
    weight_10             = 'Hn',         48   # Weight/10
                                               # (Open) In
                                               # (Open) Jn

class F322(FISenum):
    """
    IFDT - FORMULA DETAIL - INGREDIENT DETAIL
    """
    company_id                = 'An$(1,2)',    0       # Company Code
    formula_id                = 'An$(3,10)',   1       # Formula Code
    rev_id                    = 'An$(15,3)',   3       # Revision Number
    key_type                  = 'An$(18,1)',   4       # Key Group = "0"
    line_id                   = 'An$(19,3)',   5       # Line Number
    ingr_id_batch_1           = 'Bn$(1,8)',    6       # Ingredient Code - Batch 1
    item_type_batch_1         = 'Cn$(1,1)',   10       # Item Type - Batch 1
    units_batch_1             = 'Dn$(1,2)',   14       # Units - Batch 1
    desc_batch_1              = 'Fn$(1,48)',  19       # Desc - Batch 1
    lbl_claim_batch_1         = 'Gn$(1,8)',   23       # Lbl Claim - Batch 1
    pct_over_batch_1          = 'Hn$(1,2)',   27       # Pct Over - Batch 1
    pct_in_formula_batch_1    = 'A(1)',       31       # Pct In Formula - Batch 1
    qty_batch_1               = 'B(1)',       35       # Qty - Batch 1

class F323(FISenum):
    """
    IFDT1 - FORMULA DETAIL - PRODUCTION INFO
    """
    company_id     = 'An$(1,2)',   0    # Company Code
    formula_id     = 'An$(3,10)',  1    # Formula Code
    rev_id         = 'An$(15,3)',  3    # Revision Number
    key_type       = 'An$(18,1)',  4    # Key Group = "1"
    batch_id       = 'An$(19,2)',  5    # Batch Id
    desc           = 'Bn$',        6    # Description
    comments       = 'Cn$',        7    # Comments
    gross_weight   = 'An',        13    # Gross Weight (Lbs)
    yield_in_units = 'Bn',        14    # Yield In Units
    yield_pct      = 'Cn',        15    # Yield %
    labor_hours    = 'Dn',        16    # Labor Hours

class F328(FISenum):
    """
    IFPP0 - SALES ORDER PRODUCTION PENDING - HEADER
    """
    company_id              = 'An$(1,2)',      0   # Company Code
    order_no                = 'An$(3,6)',      1   # Order Number
    release_no              = 'An$(9,2)',      2   # Release No
    seq_no                  = 'An$(11,3)',     3   # Sequence No
    record_type_0000        = 'An$(14,4)',     4   # Record Type = '0000'
    formula_type            = 'Bn$(2,1)',      6   # Formula Type (P/L/T/X/V/K)
    produced                = 'Bn$(8,1)',     12   # Produced (Y/N/P/X)
    confirmed               = 'Bn$(13,1)',    16   # Order Confirmed?
    prod_id                 = 'Cn$(1,8)',     18   # Product Number
    label                   = 'Cn$(9,6)',     19   # Label
    pallets                 = 'Cn$(15,4)',    20   # Pallets
    formula_id              = 'Cn$(19,10)',   21   # Formula Code
    formula_rev             = 'Cn$(29,3)',    22   # Formula Revision
    label_name              = 'Cn$(111,40)',  31   # Label Name
    dept_id                 = 'Cn$(157,2)',   35   # Department Code
    prod_line               = 'Cn$(159,2)',   36   # Production Line
    prod_sched_date         = 'Fn$(1,6)',     40   # Production Scheduled Date
    prod_date               = 'Fn$(13,6)',    42   # Production Date
    units_ordered           = 'An',           50   # Units Ordered
    prod_qty                = 'Bn',           51   # Production Qty
    units_produced          = 'Ln',           61   # Units Produced
    no_of_lots_produced     = 'Mn',           62   # No Of Lots Produced
    qty_on_order            = 'Nn',           63   # Qty On Order

class F329(FISenum):
    """
    IFPP1 - SALES ORDER PRODUCTION PENDING - DETAIL
    """
    company_id             = 'An$(1,2)',   0   # Company Code
    order_no               = 'An$(3,6)',   1   # Order Number
    release_no             = 'An$(9,2)',   2   # Release No
    sales_order_seq        = 'An$(11,3)',  3   # Sales Order Seq
    key_type               = 'An$(14,1)',  4   # Key Type = "1"
    formula_line_no        = 'An$(15,3)',  5   # Formula Line No
    ingr_id_batch_1        = 'Bn$(1,8)',   6   # Ingredient Code - Batch 1
    item_type_batch_1      = 'Cn$(1,1)',   8   # Item Type - Batch 1
    units_batch_1          = 'Dn$(1,2)',  11   # Units - Batch 1
    desc                   = 'En$',       15   # Description (Item Or Msg)
    qty_batch_1            = 'B(1)',      23   # Quantity - Batch 1
    qty_committed_batch_1  = 'B(3)',      25   # Qty Committed - Batch 1

 # 320: IFMS-FORMULA MASTER FILE
 # 321: IFMSH-FORMULA MASTER - HISTORICAL
 # 322: IFDT-FORMULA DETAIL - INGREDIENT DETAIL
 # 323: IFDT1-FORMULA DETAIL - PRODUCTION INFO
 # 324: IFTX-FORMULA DETAIL - BATCHING DIRECTIONS
 # 325: IFMFH-MASTER FORMULA HEADER FILE
 # 326: IFMFD-MASTER FORMULA DETAIL FILE
 # 327: IFIW-INGREDIENT USAGE BY FORMULA XREF FILE
 # 328: IFPP0-SALES ORDER PRODUCTION PENDING - HEADER
 # 329: IFPP1-SALES ORDER PRODUCTION PENDING - DETAIL

Main()
