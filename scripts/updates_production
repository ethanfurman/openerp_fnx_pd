#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import IntEnum
from antipathy import Path
from dbf import Date, Time, DateTime
from collections import defaultdict
from fis_schema import F320, F322, F328, F329
from openerplib import AttrDict, get_connection, get_records, Many2One, Query
from openerplib.dates import date_to_str, datetime_to_str, local_to_utc
from pandaemonium import PidLockFile
from pytz import timezone
from recipe import ignored_ingredients
from time import sleep
from tools import allow_exception, close_enough, combine_by_value, Model, compare_fis_records as get_changed_fis_records
from VSS.BBxXlate.fisData import fisData
from VSS.constants import Weekday
from VSS.finance import FederalHoliday
from VSS.utils import fix_date
from VSS.xl import open_workbook
import os


C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

UTC = timezone('UTC')
with open('/etc/timezone') as tz:
    LTZ = timezone(tz.read().strip())

QAll_C = IntEnum(
    'QAll_C',
    'HEADER EMAIL DEPT PROD_LINE TYPE ITEM_CODE ITEM_DESC ORDER_NUM CONFIRMED QTY DATE DAY COATING ALLERGENS'.split(),
    start=0,
    )
HEADER, EMAIL, DEPT, PROD_LINE, TYPE, ITEM_CODE, ITEM_DESC, \
    ORDER_NUM, CONFIRMED, QTY, DATE, DAY, COATING, ALLERGENS = QAll_C

# TODO: implement EXTRA handling for
#       - IFPP
#       - IFMS
#       - IFDT
#       - QALL

# API
@Script(
        dryrun=Spec('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        raise_on_exception=Spec('do not ignore exceptions', FLAG, abbrev=('r', 'raise')),
        )
def main(dryrun, list_records, raise_on_exception):
    global config, oe, errors, DRYRUN, LIST_RECORDS, RAISE_ON_EXCEPTION, VIEW_TYPE, BORDER, script_verbosity
    global ifpp0  # production pending header
    global ifpp1  # production pending detail
    global ifdt   # formula detail, ingredient
    global ifdt1  # formula detail, production info
    global ifms   # formula master
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    if list_records:
        LIST_RECORDS = True
        if not script_verbosity:
            script_verbosity = 1
    RAISE_ON_EXCEPTION = raise_on_exception
    VIEW_TYPE = 'none' if LIST_RECORDS else 'percent'
    BORDER = 'box' if LIST_RECORDS and script_verbosity > 1 else None

@Command(
        files=Spec('files to check for updates (separated by a comma)', ),
        method=Spec(
            'perform quick or full comparison [quick: compare against old FIS file;'
            ' full: compare against OpenERP records; QALL only checked on full]',
            OPTION,
            choices=['quick', 'full'],
            force_default='quick',
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        extra=Spec('extra arguments', OPTION),
        )
def fnx_pd(method, delete, *files, **extra):
    global DELETE, EXTRA, oe_products, oe_production_lines, today, cutoff
    EXTRA = extra
    today = Date.today()
    cutoff = FederalHoliday.next_business_day(today, 15)
    DELETE = delete
    print('attempting a %s compare' % method)
    try:
        with PidLockFile('/var/run/fnx_pd_update.pid'):
            oe_products = dict([
                (r.xml_id, Many2One(r.id, r.name))
                for r in get_records(
                    oe, 'product.product',
                    domain=[('module','=','F135')],
                    fields=['id','xml_id','name'],
                    context={'active_test': False},
                )])
            line_ids = {}
            oe_production_lines = {}
            for line in get_records(
                    oe,
                    'fis_integration.production_line',
                    fields=['id','xml_id','name'],
                ):
                line_ids[line.id] = line
                oe_production_lines[line.xml_id] = [Many2One(line.id, line.name)]
            for multiline in Query(
                    oe.get_model('fnx.pd.multiline'),
                    fields=['id', 'key', 'line_ids/line_id'],
                ):
                lines = []
                for ml in multiline.line_ids:
                    lines.append(ml.line_id)
                oe_production_lines[multiline.key] = lines
            #
            with allow_exception(Exception):
                if 'IFPP' in files:
                    handle_production_order(method)
                    handle_production_detail(method)
            with allow_exception(Exception):
                if 'IFMS' in files:
                    handle_product_formula(method)
            with allow_exception(Exception):
                if 'IFDT' in files:
                    handle_product_ingredient(method)
            files = tuple([f for f in files if f not in ('IFPP', 'IFMS', 'IFDT')])
            with allow_exception(Exception):
                if method == 'full':
                    # do not run until 0545
                    mark = Time(5, 45)
                    while Time.now() < mark:
                        sleep(60)
                    handle_qall(*files)
    finally:
        for m, problems in sorted(Model.errors.items()):
            error('\n', m, border=('lined', '='), sep='')
            for p in problems:
                error('  ', p)
            error()

@Command(
        old=('file with older order information', ),
        new=('file with newer order information', ),
        order=('individual orders to check', MULTI),
        )
def diff(old, new, order):
    old_qall = convert_spreadsheet(old)
    new_qall = convert_spreadsheet(new)
    new_orders = dead_orders = changed_orders = 0
    for i, order_no in enumerate(sorted(set(old_qall.keys() + new_qall.keys()))):
        if order and order_no not in order:
            continue
        old_order = old_qall.get(order_no)
        new_order = new_qall.get(order_no)
        if old_order == new_order:
            continue
        elif new_order is None:
            dead_orders += 1
            print('deleted order: %s' % order_no)
            continue
        elif old_order is None:
            new_orders += 1
            print('new order: %s' % order_no)
            continue
        changed_orders += 1
        print('changes in order: %s' % order_no)
        for field in ('user','dept','line','item','desc','conf','qty','date','day','coating','allergens'):
            if old_order[field] != new_order[field]:
                print('   %s:  %-50s  -->  %s' % (field, old_order[field], new_order[field]))
    print('total orders: %r\ndeleted orders: %r\nnew orders: %r\nchanged orders: %r'
            % (i, dead_orders, new_orders, changed_orders), border='box')


@Command(
        purge=('remove found duplicates', FLAG),
        )
def duplicates(purge):
    "find duplicate order numbers"
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    fnx_pd_order = oe.get_model('fnx.pd.order')
    all_orders = {}
    for rec in get_records(
            fnx_pd_order,
            domain=[('order_no','!=','CLEAN')],
            fields=['id', 'order_no', 'state', 'item_id', 'line_id', 'schedule_date'],
        ):
        all_orders.setdefault(rec.order_no, []).append(rec)
    last_order = None
    processed = set()
    to_be_purged = set()
    check_for_purge = dict()
    for order_no, orders in sorted(all_orders.items()):
        found_old = False
        if len(order_no) > 6 and order_no[:6] not in processed:
            processed.add(order_no[:6])
            # check for old 6-digit order
            old_order = all_orders.get(order_no[:6])
            if old_order is not None:
                found_old = True
                [old_order] = old_order
                to_be_purged.add(old_order.id)
        if found_old:
            if order_no[:6] != last_order:
                echo()
                last_order = order_no[:6]
            echo('%s\n------------' % order_no[:6])
            echo('   %-60s  %-30s  %10s  %s'
                    % (old_order.item_id[1], old_order.line_id[1], old_order.schedule_date, old_order.state)
                    )
        if len(orders) < 2:
            continue
        if order_no[:6] != last_order:
            echo()
            last_order = order_no[:6]
        echo('%s\n------------' % order_no)
        for order in orders:
            check_for_purge.setdefault(order_no, []).append(order)
            echo('   %-60s  %-30s  %10s  %s'
                    % (order.item_id[1], order.line_id[1], order.schedule_date, order.state)
                    )
    echo()
    if purge:
        # compare orders in check_for_purge against FIS tables to determine which to keep
        # and which to delete
        ifpp = fisData(328, subset='10%s')
        line_ids = {}
        oe_production_lines = {}
        for line in get_records(
                oe,
                'fis_integration.production_line',
                fields=['id','xml_id','name'],
            ):
            line_ids[line.id] = line
            oe_production_lines[line.xml_id] = [Many2One(line.id, line.name)]
        for multiline in get_records(
                oe,
                'fnx.pd.multiline',
                fields=['key', 'line_ids'],
            ):
            lines = []
            for ml in multiline.line_ids:
                lines.append(Many2One(ml, line_ids[ml].name))
            oe_production_lines[multiline.key] = lines
        for oe_order_no, oe_orders in sorted(check_for_purge.items()):
            fis_order_no = oe_order_no[:6]
            [key_rec] = ifpp.get_subset(fis_order_no)
            fis_order = key_rec[1]
            multiline = oe_production_lines[fis_order[F328.prod_line]]
            step = int(oe_order_no[7])
            index = step - 1
            correct_line = multiline[index]
            for oe_order in oe_orders:
                if oe_order.line_id != correct_line:
                    to_be_purged.add(oe_order.id)
        fnx_pd_order.unlink(tuple(to_be_purged))
        echo('%d orders removed' % len(to_be_purged))


# helpers

def handle_product_formula(method):
    print('processing product formulae (IFMS - 320)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_formula = Model(oe.get_model('fnx.pd.product.formula'), 'ifms', 'F320', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_formula_records = {}
    old_formula_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_formula_records = {}
    new_changed_formula_records = {}
    # these are for added/deleted records
    added_formula_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    ifms = fisData(320, rematch=r'10........0000')
    print('%s:  %d records' % (ifms.filename, len(ifms)), verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifms_old = fisData(320, rematch=r'10........0000', data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifms_old.filename, len(ifms_old)), verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifms_old.values(),
                ifms.values(),
                enum_schema=[
                    F320.formula_id, F320.rev_no,
                    F320.desc, F320.coating, F320.allergens,
                    ],
                address_fields=[],
                ignore=lambda r: len(r[F320.formula_id]) != 6,
                )
        #
        # and convert the new, changed, and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            added_formula_records[fis_rec[F320.formula_id]] = convert_ifms_rec(fis_rec)
        for fis_rec in deleted:
            deleted_records[fis_rec[F320.formula_id]] = convert_ifms_rec(fis_rec)
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            formula = old[F320.formula_id]
            old_formula = convert_ifms_rec(old)
            new_formula = convert_ifms_rec(new)
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_formula != new_formula:
                old_formula_records[formula] = old_formula
                new_formula_records[formula] = new_formula
            assert set(old_changed_formula_records.keys()) == set(new_changed_formula_records.keys()),\
                    "old and new formula records mismatch"
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, the compare against all
        # formulas
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifms.values():
            if len(fis_rec[F320.formula_id]) != 6:
                continue
            rec = convert_ifms_rec(fis_rec)
            all_fis_records[rec.formula] = rec
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.formula, r)
            for r in fnx_pd_formula.read(
                fields=[
                    'id', 'name', 'formula', 'description', 'coating', 'allergens',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for formula in set(all_oe_records.keys() + all_fis_records.keys()):
            old_formula = all_oe_records.get(formula)
            new_formula = all_fis_records.get(formula)
            if old_formula is None:
                added_formula_records[formula] = new_formula
                continue
            elif new_formula is None:
                deleted_records[formula] = old_formula
                continue
            # now normalize records for good comparison
            new_formula.id = old_formula.id
            if old_formula == new_formula or close_enough(old_formula, new_formula):
                continue
            else:
                old_changed_formula_records[formula] = old_formula
                new_changed_formula_records[formula] = new_formula
        assert set(old_changed_formula_records.keys()) == set(new_changed_formula_records.keys()),\
                "old and new formula records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing formulas
    print('adding records')
    formula_names = added_formula_records.keys()
    existing_formulae = [
        f.name
        for f in fnx_pd_formula.read(
                domain=[('name','in',formula_names)],
                fields=['id','name'],
                )]
    for full_name, formula in added_formula_records.items():
        if full_name in existing_formulae:
            fnx_pd_formula.error('FIS Order F320:%s already exists in OpenERP' % (full_name, ))
            continue
        added_count += 1
        name = formula.name
        if LIST_RECORDS:
            echo('  F320:%s' % name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in formula.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_formula.create(full_name, formula)
    #
    # process deletions, but only for formulas that still exist
    #
    print('removing records')
    formula_names = deleted_records.keys()
    formulas = dict([
        (f.id, f)
        for f in fnx_pd_formula.read(
                domain=[('formula','in',formula_names)],
                fields=['id','formula'],
                )])
    if formulas:
        deleted_count = len(formulas)
        if LIST_RECORDS:
            echo('\n'.join(['  F320:%s' % f.formula for f in formulas.values()]))
        if not DRYRUN:
            fnx_pd_formula.unlink(formulas.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_formula_records, new_changed_formula_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        formulae = [r.formula for r in records]
        oe_ids = fnx_pd_formula.search([('formula','in',formulae)])
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for f in records:
                body.append(('  F135:%s' % (f.formula, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_formula.write('|'.join(formulae), oe_ids, values, context={})
    #
    print('%d formulas changed\n%d formulas added\n%d formulas deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_product_ingredient(method):
    print('processing product ingredients (IFDT - 322)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_ingredient = Model(oe.get_model('fnx.pd.product.ingredient'), 'ifdt', 'F322', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_ingredient_records = {}
    old_ingredient_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_ingredient_records = {}
    new_changed_ingredient_records = {}
    # these are for added/deleted records
    added_ingredient_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    formulae = dict([
        (f.formula, Many2One(f.id, f.formula))
        for f in get_records(oe, 'fnx.pd.product.formula', fields=['id','formula'])
        ])
    oe_items = dict([
        (i.xml_id, Many2One(i.id, i.xml_id))
        for i in get_records(oe, 'product.product', fields=['id','xml_id'], domain=[('module','=','F135')])
        ])
    ifdt = fisData(322, rematch=r'10........0000...')
    print('%s:  %d records' % (ifdt.filename, len(ifdt)), verbose=2)
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifdt_old = fisData(322, rematch=r'10........0000...', data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifdt_old.filename, len(ifdt_old)), verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifdt_old.values(),
                ifdt.values(),
                enum_schema=[
                    F322.formula_id, F322.rev_no, F322.desc_batch_1, F322.line_no,
                    ],
                address_fields=[],
                ignore=lambda r: ('%s-%s' % (r[F322.formula_id], r[F322.rev_no]) not in formulae
                                  or r[F322.ingr_code_batch_1] not in oe_items
                                  or r[F322.ingr_code_batch_1] in ignored_ingredients
                                  ),
                )
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            oe_rec = convert_ifdt_rec(fis_rec)
            oe_rec.formula_id = formulae[oe_rec.formula_id]
            oe_rec.item_id = oe_items[oe_rec.item_id]
            added_ingredient_records[oe_rec.name] = oe_rec
        for fis_rec in deleted:
            oe_rec = convert_ifdt_rec(fis_rec)
            deleted_records[oe_rec.name] = oe_rec
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            old_ingredient = convert_ifdt_rec(old)
            new_ingredient = convert_ifdt_rec(new)
            name = old_ingredient.name
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_ingredient == new_ingredient:
                continue
            old_ingredient.formula_id = formulae[old_ingredient.formula_id]
            new_ingredient.formula_id = formulae[new_ingredient.formula_id]
            old_ingredient.item_id = oe_items[old_ingredient.item_id]
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            old_ingredient_records[name] = old_ingredient
            new_ingredient_records[name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                fields=[
                    'id', 'name', 'sequence', 'formula_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, then compare against all
        # ingredients
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifdt.values():
            if '%s-%s' % (fis_rec[F322.formula_id], fis_rec[F322.rev_no]) not in formulae:
                continue
            if fis_rec[F322.ingr_code_batch_1] not in oe_items:
                continue
            if fis_rec[F322.ingr_code_batch_1] in ignored_ingredients:
                continue
            ingredient = convert_ifdt_rec(fis_rec)
            all_fis_records[ingredient.name] = ingredient
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                fields=[
                    'id', 'name', 'sequence', 'formula_id', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for ingredient_name in ProgressView(
                iterable=set(all_oe_records.keys() + all_fis_records.keys()),
                message='sorting records',
                view_type=VIEW_TYPE,
                ):
            old_ingredient = all_oe_records.get(ingredient_name)
            new_ingredient = all_fis_records.get(ingredient_name)
            if old_ingredient is None:
                new_ingredient.formula_id = formulae[new_ingredient.formula_id]
                new_ingredient.item_id = oe_items[new_ingredient.item_id]
                added_ingredient_records[ingredient_name] = new_ingredient
                continue
            elif new_ingredient is None:
                deleted_records[ingredient_name] = old_ingredient
                continue
            # now normalize records for good comparison
            new_ingredient.id = old_ingredient.id
            new_ingredient.formula_id = formulae[new_ingredient.formula_id]
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            if old_ingredient == new_ingredient:
                continue
            else:
                old_changed_ingredient_records[ingredient_name] = old_ingredient
                new_changed_ingredient_records[ingredient_name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing ingredients
    print('adding records')
    ingredient_names = added_ingredient_records.keys()
    existing_ingredients = [
        i.name
        for i in fnx_pd_ingredient.read(
                domain=[('name','in',ingredient_names)],
                fields=['id','name'],
                )]
    for full_name, ingredient in added_ingredient_records.items():
        if full_name in existing_ingredients:
            fnx_pd_ingredient.error('FIS Order F322:%s already exists in OpenERP' % (full_name, ))
            continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F322:%s' % full_name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in ingredient.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_ingredient.create(full_name, ingredient)
    #
    # process deletions, but only for ingredients that still exist
    #
    print('removing records')
    ingredient_names = deleted_records.keys()
    ingredients = dict([
        (i.id, i)
        for i in fnx_pd_ingredient.read(
                domain=[('name','in',ingredient_names)],
                fields=['id','name'],
                )])
    if ingredients:
        deleted_count = len(ingredients)
        if LIST_RECORDS:
            echo('\n'.join(['  F322:%s' % i.name for i in ingredients.values()]))
        if not DRYRUN:
            fnx_pd_ingredient.unlink(ingredients.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_ingredient_records, new_changed_ingredient_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        ingredients = [r.name for r in records]
        oe_ids = []
        for rec in records:
            oe_ids.append(all_oe_records[rec.name].id)
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for i in records:
                body.append(('  F135:%s' % (i.name, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_ingredient.write('|'.join(ingredient), oe_ids, values, context={})
    #
    print('%d ingredients changed\n%d ingredients added\n%d ingredients deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_production_order(method):
    #
    # to fix wrong names format
    #   update fnx_pd_order set order_no = regexp_replace(order_no, '(\d*)_(\d_\d)', '\1-\2');
    #
    global ifms
    cutoff_date = cutoff.strftime('%Y-%m-%d')
    print('processing production orders (IFPP0 - 328)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_order = Model(oe.get_model('fnx.pd.order'), 'ifpp0', 'F328', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # these are for tracking original old/new records
    new_order_records = {}
    old_order_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_order_records = {}
    new_changed_order_records = {}
    # these are for added/deleted records
    added_order_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    ifpp0 = fisData(328, rematch=r'10......000010000')
    ifms = fisData(320, rematch=r'10........0000')
    print(ifpp0.filename, len(ifpp0), verbose=2)
    #
    target_order = EXTRA.get('order')
    def ignore_order(order):
        return target_order and target_order != order[F328.order_no]
    #
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifpp_old = fisData(328, rematch=r'10......000010000', data_path=config.network.fis_data_local_old_path)
        print(ifpp_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifpp_old.values(),
                ifpp0.values(),
                enum_schema=[
                    F328.order_no, F328.produced, F328.order_confirmed, F328.prod_no,
                    F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
                    F328.prod_scheduled_date, F328.prod_date, F328.units_produced,
                    ],
                address_fields=[],
                ignore=ignore_order,
                )
        #
        # and convert the new and deleted records
        #
        print('sorting %d new and %d deleted records' % (len(added), len(deleted)))
        for fis_rec in added:
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                added_order_records[rec.order_no] = add_ac(fis_rec, rec)
        for fis_rec in deleted:
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                deleted_records[rec.order_no] = rec
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting $total changed records',
                view_type=VIEW_TYPE,
            ):
            order_no = old[F328.order_no]
            old_order = convert_ifpp0_rec(old)
            old_order_records[order_no] = old_order
            new_order = convert_ifpp0_rec(new)
            new_order_records[order_no] = new_order
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_order != new_order:
                # split orders up
                old_orders = split_steps(old_order)
                new_orders = split_steps(new_order)
                for order_no in set(old_orders.keys() + new_orders.keys()):
                    old_order = old_orders.get(order_no)
                    new_order = new_orders.get(order_no)
                    if old_order is None:
                        added_order_records[order_no] = new_order
                    elif new_order is None:
                        if old_order.state not in ('complete', 'cancelled'):
                            deleted_records[order_no] = old_order
                    else:
                        old_changed_order_records[order_no] = old_order
                        new_changed_order_records[order_no] = new_order
            assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                    "old and new order records mismatch"
        all_oe_records = dict([
            (r.order_no, r)
            for r in fnx_pd_order.read(
                domain=[
                    ('order_no','in',
                        added_order_records.keys()
                        + deleted_records.keys()
                        + old_changed_order_records.keys()
                        ),
                    ],
                fields=[
                    'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
                    'formula_code', 'dept', 'line_id', 'schedule_date', 'finish_date',
                    'line_id_set', 'schedule_date_set', 'state',
                    ],
                )])
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, the compare against all open
        # orders and closed/cancelled orders referenced by the fis records
        #
        # fis first
        #
        print('getting fis records')
        order_numbers = []
        for fis_rec in ifpp0.values():
            for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                if target_order and not rec.order_no.startswith(target_order):
                    continue
                order_numbers.append(rec.order_no)
                all_fis_records[rec.order_no] = rec
        #
        # and then openerp
        #
        print('getting openerp records')
        all_oe_records = dict([
            (r.order_no, r)
            for r in fnx_pd_order.read(
                domain=[
                    '|',
                    ('order_no','in',order_numbers),
                    ('state','in',['draft','sequenced','released','running','stopped']),
                    ],
                fields=[
                    'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
                    'formula_code', 'dept', 'line_id', 'schedule_date', 'finish_date',
                    'line_id_set', 'schedule_date_set', 'state',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for order_no in set(all_oe_records.keys() + all_fis_records.keys()):
            old_order = all_oe_records.get(order_no)
            new_order = all_fis_records.get(order_no)
            if old_order is None:
                added_order_records[order_no] = new_order
                continue
            elif new_order is None:
                if old_order.state not in ('complete', 'cancelled'):
                    deleted_records[order_no] = old_order
                continue
            # save for later comparison
            old_changed_order_records[order_no] = old_order
            new_changed_order_records[order_no] = new_order
        assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                "old and new order records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process changes
    #
    print('%d records in changed' % len(old_changed_order_records), verbose=2)
    for order_no, new_order in ProgressView(
            iterable=new_changed_order_records.items(),
            message='double-checking $total changes',
            view_type=VIEW_TYPE
        ):
        # is order out of range?
        if new_order.schedule_date > cutoff_date:
            deleted_records[order_no] = new_order
            del old_changed_order_records[order_no]
            del new_changed_order_records[order_no]
            continue
        old_order = all_oe_records.get(order_no)
        if old_order is None:
            added_order_records[order_no] = new_order
            del old_changed_order_records[order_no]
            del new_changed_order_records[order_no]
            continue
        # now normalize records for good comparison
        new_order.id = old_order.id
        new_order.state = new_order.state or old_order.state
        if old_order.line_id_set:
            new_order.line_id_set = True
            new_order.line_id = old_order.line_id
        if old_order.schedule_date_set:
            new_order.schedule_date_set = True
            new_order.schedule_date = old_order.schedule_date
        # and check for actionable changes
        if new_order == old_order:
            del old_changed_order_records[order_no]
            del new_changed_order_records[order_no]
            continue
        else:
            # update old_changed_order_records in case method is 'quick'
            old_changed_order_records[order_no] = old_order
    #
    changed_map = combine_by_value(old_changed_order_records, new_changed_order_records)
    print('%d groups in changed_map' % len(changed_map), verbose=2)
    print('%d records in those groups' % sum([len(r) for r in changed_map.values()]), verbose=2)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        order_nos = [r.order_no for r in records]
        print('values: ', values, verbose=2)
        print('order numbers: ', order_nos, verbose=2)
        oe_ids = dict([
            (r.order_no, r)
            for r in
                fnx_pd_order.read(domain=[('order_no','in',order_nos)], fields=['id','order_no'])
                ])
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  F135:%s' % (rec.order_no, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            for order_no in order_nos:
                fnx_pd_order.write(order_no, oe_ids[order_no].id, values, context={})
    # process additions, checking first for already existing orders
    print('adding records')
    order_nos = added_order_records.keys()
    existing_order_nos = [o.order_no for o in all_oe_records.values()]
    for order_no, order in added_order_records.items():
        if order_no in existing_order_nos:
            fnx_pd_order.error('FIS Order F328:%s already exists in OpenERP' % (order_no, ))
            continue
        if cutoff < order.schedule_date:
            continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F328:%s' % order_no, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in order.items()]), end='', verbose=2)
            echo('\n', '- -' * 25)
        if not DRYRUN:
            fnx_pd_order.create(order_no, order)
    #
    # process deletions, but only for orders that still exist
    #
    print('removing records')
    order_nos = deleted_records.keys()
    orders = dict([(o.id, o) for o in all_oe_records.values() if o.order_no in deleted_records])
    if orders:
        deleted_count = len(orders)
        if LIST_RECORDS:
            echo('\n'.join(['  F328:%s' % o.order_no for o in orders.values()]))
        if not DRYRUN:
            fnx_pd_order.unlink(orders.keys())
    #
    print('%d orders changed\n%d orders added\n%d orders deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_production_detail(method):
    global ifpp0, oe_orders
    print('processing product ingredients (IFPP1 - 329)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fnx_pd_ingredient = Model(oe.get_model('fnx.pd.ingredient'), 'ifpp1', 'F329', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    all_fis_records = {}
    # all old and new records
    old_ingredient_records = {}
    new_ingredient_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_ingredient_records = {}
    new_changed_ingredient_records = {}
    # these are for added/deleted records
    added_ingredient_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data')
    oe_orders = {}
    oe_static_orders = set()
    for order in get_records(oe, 'fnx.pd.order', fields=['id','order_no','state']):
        order.id = Many2One(order.id, order.order_no)
        if order.state in ('complete', 'cancelled'):
            oe_static_orders.add(order.order_no[:6])
        else:
            oe_orders.setdefault(order.order_no[:6], []).append(order)
    for static_order in oe_static_orders:
        oe_orders.pop(static_order, None)
    print('%d orders' % len(oe_orders))
    oe_items = dict([
        (i.xml_id, Many2One(i.id, i.xml_id))
        for i in get_records(oe, 'product.product', fields=['id','xml_id'], domain=[('module','=','F135')])
        ])
    print('%d items found' % len(oe_items), verbose=2)
    ifpp0 = fisData(328, keymatch='10%s00010000', rematch=r"10......000010000")
    ifpp1 = fisData(329, rematch=r"10......000010000...")
    print('%s:  %d records' % (ifpp1.filename, len(ifpp1)), verbose=2)
    #
    target_order = EXTRA.get('order')
    def ignore_order_detail(rec):
        if target_order and rec['F329.order_no'] != target_order:
            return True
        if rec[F329.item_type_batch_1] == 'M':
            return True
        elif rec[F329.ingr_code_batch_1] in ignored_ingredients:
            return True
        order_no = rec[F329.order_no]
        if order_no not in oe_orders:
            return True
        if all([order.state in ['complete','cancelled'] for order in oe_orders[order_no]]):
            return True
        return False
    #
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        ifpp1_old = fisData(329, rematch=r"10......000010000...", data_path=config.network.fis_data_local_old_path)
        print('%s:  %d records' % (ifpp1_old.filename, len(ifpp1_old)), verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                ifpp1_old.values(),
                ifpp1.values(),
                enum_schema=[
                    F329.order_no, F329.ingr_code_batch_1, F329.units_batch_1, F329.qty_batch_1, F329.formula_line_no
                    ],
                address_fields=[],
                ignore=ignore_order_detail,
                key=(F329.company_id, F329.order_no, F329.ingr_code_batch_1),
                )
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            new_ingredient = convert_ifpp1_rec(fis_rec)
            order_no = new_ingredient.order_id
            if order_no in oe_orders:
                if any(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                    new_ingredient.order_ids = [o.id for o in oe_orders[order_no]]
                    del new_ingredient.order_id
            else:
                fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
            new_ingredient.item_id = oe_items[new_ingredient.item_id]
            added_ingredient_records[new_ingredient.name] = new_ingredient
            new_ingredient_records[new_ingredient.name] = new_ingredient
        for fis_rec in deleted:
            old_ingredient = convert_ifpp1_rec(fis_rec)
            order_no = old_ingredient.order_id
            if order_no in oe_orders:
                if all(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                    deleted_records[old_ingredient.name] = old_ingredient
                    old_ingredient_records[old_ingredient.name] = old_ingredient
            else:
                fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            new_ingredient = convert_ifpp1_rec(new)
            old_ingredient = convert_ifpp1_rec(old)
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_ingredient == new_ingredient:
                continue
            order_no = new_ingredient.order_id
            if order_no in oe_orders:
                order_ids = [o.id for o in oe_orders[order_no]]
                if any(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                    old_ingredient.order_ids = order_ids
                    new_ingredient.order_ids = order_ids
                    del old_ingredient.order_id
                    del new_ingredient.order_id
                    old_ingredient.item_id = oe_items[old_ingredient.item_id]
                    new_ingredient.item_id = oe_items[new_ingredient.item_id]
                    old_changed_ingredient_records[old_ingredient.name] = old_ingredient
                    old_ingredient_records[old_ingredient.name] = old_ingredient
                    new_changed_ingredient_records[new_ingredient.name] = new_ingredient
                    new_ingredient_records[new_ingredient.name] = new_ingredient
            else:
                fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch\n%r\%r" % (
                        sorted(old_changed_ingredient_records),
                        sorted(new_changed_ingredient_records),
                        )
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                domain=[('name','in',
                        added_ingredient_records.keys()
                        +deleted_records.keys()
                        +old_changed_ingredient_records.keys()
                        )],
                fields=[
                    'id', 'name', 'order_ids', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        # update old records to OpenERP version;
        # possibly move records to added category
        for name, old_ingredient in old_changed_ingredient_records.items():
            if name in all_oe_records:
                old_changed_ingredient_records[name] = all_oe_records[name]
                new_changed_ingredient_records[name].id = all_oe_records[name].id
                continue
            elif name in new_ingredient_records:
                # record doesn't exist - add to added_ingredient_records and remove
                # from [old|new]_changed_ingredient_records
                added_ingredient_records[name] = new_ingredient_records[name]
            else:
                fnx_pd_ingredient('%s not found in OpenERP' % name)
            del old_changed_ingredient_records[name]
            del new_changed_ingredient_records[name]
    elif method == 'full':
        #
        # for a full compare we fully convert the fis records, then compare against all
        # ingredients
        #
        # fis first
        #
        print('getting fis records')
        for fis_rec in ifpp1.values():
            if ignore_order_detail(fis_rec):
                continue
            ingredient = convert_ifpp1_rec(fis_rec)
            all_fis_records[ingredient.name] = ingredient
        #
        # and then openerp
        #
        print('\ngetting openerp records')
        all_oe_records = dict([
            (r.name, r)
            for r in fnx_pd_ingredient.read(
                domain=[('name','in',all_fis_records.keys())],
                fields=[
                    'id', 'name', 'sequence', 'order_ids', 'item_id', 'qty_needed', 'qty_desc',
                    ],
                )])
        #
        # and then we compare
        #
        print('sorting changed, new, and deleted records')
        for name in set(all_oe_records.keys() + all_fis_records.keys()):
            old_ingredient = all_oe_records.get(name)
            new_ingredient = all_fis_records.get(name)
            if new_ingredient is None:
                deleted_records[name] = old_ingredient
                continue
            order_ids = oe_orders.get(new_ingredient.order_id)
            if order_ids is None:
                continue
            order_ids = [o.id for o in order_ids]
            new_ingredient.order_ids = order_ids
            del new_ingredient.order_id
            item_id = oe_items.get(new_ingredient.item_id)
            if item_id is None:
                continue
            new_ingredient.item_id = item_id
            if old_ingredient is None:
                added_ingredient_records[name] = new_ingredient
                continue
            old_ingredient.pop('order_id', None)
            # now normalize records for good comparison
            new_ingredient.id = old_ingredient.id
            if old_ingredient != new_ingredient:
                old_changed_ingredient_records[name] = old_ingredient
                new_changed_ingredient_records[name] = new_ingredient
        assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                "old and new ingredient records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point all records are in AttrDict format and divided by
    # new, deleted, and changed
    #
    # process additions, checking first for already existing ingredients
    print('adding records')
    for name, ingredient in added_ingredient_records.items():
        if name in all_oe_records:
            fnx_pd_ingredient.error('FIS Order F329:%s already exists in OpenERP' % (name, ))
            continue
        added_count += 1
        ingredient.order_ids = [(6, 0, ingredient.order_ids)]
        if LIST_RECORDS:
            echo('  F329:%s' % name, end='  ')
            print(','.join(['%s=%r' % (k, v) for k, v in ingredient.items()]), end='', verbose=2)
            echo()
        if not DRYRUN:
            fnx_pd_ingredient.create(name, ingredient)
    #
    # process deletions, but only for ingredients that still exist
    #
    print('removing records')
    missing_ingredients = dict([
        (i.name, i)
        for i in all_oe_records.values()
        if i.name in deleted_records
        ])
    if missing_ingredients:
        deleted_count = len(missing_ingredients)
        if LIST_RECORDS:
            echo('\n'.join(['  F329:%s' % i.name for i in missing_ingredients.values()]))
        if not DRYRUN:
            fnx_pd_ingredient.unlink(missing_ingredients.keys())
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_ingredient_records, new_changed_ingredient_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = AttrDict(changes)
        if 'order_ids' in values:
            values.order_ids = [(6, 0, values.order_ids)]
        records = list(records)
        oe_ids = [o.id for o in records]
        names = [o.name for o in records]
        assert len(oe_ids)
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for i in records:
                body.append(('  F135:%s' % (i.name, )))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(values))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            fnx_pd_ingredient.write(', '.join(names), oe_ids, values, context={})
    #
    print('%d ingredients changed\n%d ingredients added\n%d ingredients deleted'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def handle_qall(*files):
    print('processing QAll', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    if len(files) > 1:
        abort('only one file can be specified (%r)' % (files, ))
    if files:
        [qall] = files
    else:
        # see if today's qall file exists
        qall_files = sorted(config.network.qall_files.glob(today.strftime('%Y-%m-%d_*')))
        if qall_files:
            qall = qall_files[-1]
        else:
            echo(today.strftime('no QALL file found for %Y-%m-%d'), border='box')
            return
    product_orders = Model(oe.get_model('fnx.pd.order'), 'nvty', 'F135', context, RAISE_ON_EXCEPTION)
    # variables used
    added_records = {}
    old_changed_records = {}
    new_changed_records = {}
    deleted_records = {}
    added_count = 0
    deleted_count = 0
    changed_count = 0
    #
    #
    fis_orders = convert_spreadsheet(qall)
    oe_orders = dict(
        (r.order_no, r) for r in get_records(
            oe,
            'fnx.pd.order',
            domain=[('state','in',['draft','sequenced','released','running','stopped'])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set',
                'dept', 'coating', 'allergens',
                ],
        ))
    #
    # rules for orders (failure means order is deleted from, or not entered into, OpenERP):
    # - cannot be scheduled for Saturday
    # - must be within three weeks of today (15 business days)
    # - must be present in FIS
    #
    # rules for order state:
    # - if state in FIS is
    #   - Y --> complete
    #   - X --> cancelled
    #   - P, N, or Space --> no change
    #   - anything else --> no change, and record invalid state
    #
    # trim any FIS orders that fail the first two criteria
    for order_no, order in list(fis_orders.items()):
        if order.day is Weekday.SATURDAY:
            fis_orders.pop(order_no)
        elif cutoff <= order.schedule_date:
            fis_orders.pop(order_no)
        # no longer need the day field
        del order.day
    #
    # above oe_orders only has active orders; now check for inactive orders -- we do this
    # so we don't try to add an existing order
    #
    for order in get_records(
            oe,
            'fnx.pd.order',
            domain=[('order_no','in',[ono for ono in fis_orders if ono not in oe_orders])],
            fields=[
                'state', 'order_no', 'item_id', 'ordered_qty', 'line_id', 'line_id_set', 'confirmed',
                'schedule_date', 'schedule_date_set',
                'dept', 'coating', 'allergens',
                ],
            context={'active_test': False},
        ):
        oe_orders[order.order_no] = order
    #
    # get a list of all keys, and figure out whats new, what's old, and what's changed
    #
    for order_no in sorted(list(set(oe_orders.keys() + fis_orders.keys()))):
        old_record = oe_orders.get(order_no)
        new_record = fis_orders.get(order_no)
        if old_record is None:
            # add record
            added_records[order_no] = new_record
            continue
        # if record is already done, ignore any changes
        elif old_record.state in ('complete','cancelled'):
            continue
        elif new_record is None:
            # remove record
            deleted_records[order_no] = old_record
            continue
        # update fis record with OpenERP specific data (applies to both new and changed records)
        new_record.id = old_record.id
        new_record.state = old_record.state
        new_record.line_id_set = old_record.line_id_set
        new_record.schedule_date_set = old_record.schedule_date_set
        if not new_record.confirmed:
            new_record.confirmed = old_record.confirmed
        if new_record.line_id_set:
            new_record.line_id = old_record.line_id
        if new_record.schedule_date_set:
            new_record.schedule_date = old_record.schedule_date
        if new_record == old_record:
            # no changes, move on to next record
            continue
        new_changed_records[order_no] = new_record
        old_changed_records[order_no] = old_record
    #
    # add new orders
    #
    for order_no, order in ProgressView(
            iterable=sorted(added_records.items()),
            message='adding new records',
            view_type=VIEW_TYPE,
        ):
        added_count += 1
        if LIST_RECORDS:
            echo('  QALL:%-10s  %s' % (order.order_no, order.item_id.name))
            print('     --> ', repr(order), verbose=2)
            echo()
        if not DRYRUN:
            product_orders.create(order_no, order)
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_records, new_changed_records)
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        order_nos = [r.order_no for r in records]
        oe_ids = [r.id for r in records]
        changed_count += len(oe_ids)
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  QALL:%-10s  %s' % (rec.order_no, rec.item_id.name)))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if not DRYRUN:
            product_orders.write('|'.join(order_nos), oe_ids, values, context={})
    #
    # deleted/deactivate orders
    #
    for _ in ProgressView(
            iterable=(True, ),
            message='removing irrelevent records',
            view_type=VIEW_TYPE,
        ):
        ## get the ids of actually existing records
        ids = [rec.id for key, rec in deleted_records.items()]
        if ids:
            deleted_count = len(ids)
            if deleted_count:
                if LIST_RECORDS:
                    for order_no, rec in sorted(deleted_records.items()):
                        echo('  QALL:%-10s  %s' % (order_no, rec.item_id.name))
                if not DRYRUN:
                    product_orders.delete(ids, context=context)
    #
    print('%d orders changed\n%d orders added\n%d orders removed'
            % (changed_count, added_count, deleted_count, ),
            border='box',
            )

def add_ac(fis_rec, oe_rec):
    "add allergens and coating to rec"
    # rec is in AttrDict format
    # F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
    formula_rev = '10%-8s  %-3s0' % (fis_rec[F328.formula_id], fis_rec[F328.formula_rev])
    formula_rec = ifms.get(formula_rev)
    if formula_rec:
        oe_rec.coating = formula_rec[F320.coating] or False
        oe_rec.allergens = formula_rec[F320.allergens] or False
    return oe_rec


def convert_ifdt_rec(fis_rec):
    "product ingredient"
    # convert the record into the following fields:
    #   formula_id, item_id, qty_needed, qty_desc
    #
    # using:
    #   F322.formula_id, F322.rev_no, F322.ingr_code_batch_1, F322.qty_batch_1, F322.units_batch_1
    #
    ingredient = AttrDict()
    ingredient.formula_id = formula = '%s-%s' % (fis_rec[F322.formula_id], fis_rec[F322.rev_no])
    ingredient.item_id = item = fis_rec[F322.ingr_code_batch_1]
    ingredient.name = '%s:%s' % (formula, item)
    ingredient.sequence = int(fis_rec[F322.line_no] or 0)
    ingredient.qty_needed = fis_rec[F322.qty_batch_1]
    ingredient.qty_desc = fis_rec[F322.units_batch_1]
    return ingredient

def convert_ifms_rec(fis_rec):
    "product formula"
    # convert the record into the following fields:
    #   formula, description, coating, allergens
    #
    # using:
    #   F320.formula, F320.rev_no, F320.desc, F320.coating, F320.allergens
    #
    formula = AttrDict()
    formula.name = name = fis_rec[F320.formula_id]
    formula.formula = '%s-%s' % (name, fis_rec[F320.rev_no])
    formula.description = fis_rec[F320.desc]
    formula.coating = fis_rec[F320.coating] or False
    formula.allergens = fis_rec[F320.allergens] or False
    return formula

def convert_ifpp0_rec(fis_rec):
    "sales production order"
    # convert the record into the following fields:
    #   id, order_no, completed_fis_qty, confirmed, item_id,
    #   formula_code, dept, line_id,
    #   schedule_date, finish_date, completed_fis_qty,
    #
    # F328.order_no, F328.produced, F328.order_confirmed, F328.prod_no,
    # F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
    # F328.prod_scheduled_date, F328.prod_date, F328.units_produced,
    #
    # multiple lines ARE NOT split
    #
    order = AttrDict()
    order.order_no = fis_rec[F328.order_no]
    order.completed_fis_qty = fis_rec[F328.units_produced]
    status = fis_rec[F328.produced]
    if status == 'Y':
        order.state = 'complete'
    elif status == 'X':
        order.state = 'cancelled'
    else:
        order.state = False
    order.confirmed = (False, 'fis')[fis_rec[F328.order_confirmed] == 'Y']
    order.item_id = oe_products[fis_rec[F328.prod_no]]
    order.formula_code = '[%s-%s] %s' % (
            fis_rec[F328.formula_id].strip(), fis_rec[F328.formula_rev], fis_rec[F328.label_name],
            )
    order.dept = fis_rec[F328.dept_id] or False
    line_id = fis_rec[F328.prod_line] or False
    if line_id and len(line_id) == 1:
        line_id = '0' + line_id
    order.line_id = line_id
    order.line_id_set = False
    sched_date = fix_date(fis_rec[F328.prod_scheduled_date], 'ymd') or False
    if sched_date:
        sched_date = date_to_str(sched_date)
    order.schedule_date = sched_date
    order.schedule_date_set = False
    fin_date = fix_date(fis_rec[F328.prod_date], 'mdy') or False
    if fin_date:
        fin_date = datetime_to_str(local_to_utc(DateTime.combine(fin_date, Time(17))))
    order.finish_date = fin_date
    order.completed_fis_qty = fis_rec[F328.units_produced] or False
    return order

def convert_ifpp1_rec(fis_rec):
    "order ingredient"
    # convert the record into the following fields:
    #   name, order_id, item_id, qty_needed, qty_desc
    #
    # multiply qty_needed by F328.no_of_batches_a
    #
    # using:
    #   F329.order_no, F329.ingr_code_batch_1, F329.qty_batch_1, F329.units_batch_1
    #
    ingredient = AttrDict()
    ingredient.order_id = order = fis_rec[F329.order_no]
    ingredient.order_ids = oe_orders.get(order, [])
    #
    batches_needed = ifpp0[order][F328.no_of_batches_a]
    #
    ingredient.item_id = item = fis_rec[F329.ingr_code_batch_1]
    ingredient.name = '%s:%s' % (order, item)
    ingredient.sequence = int(fis_rec[F329.formula_line_no] or 0)
    ingredient.qty_needed = fis_rec[F329.qty_batch_1] * batches_needed
    ingredient.qty_desc = fis_rec[F329.units_batch_1]
    return ingredient

def convert_spreadsheet(file_name):
    'convert records on 21-day tab into schedule records'
    print('processing %s' % file_name)
    #
    # get spreadsheet data
    #
    orders = {}
    sheet_data = []
    with open_workbook(file_name) as work_book:
        for sheet in work_book:
            if sheet.name.lower() == '21 day production schedule':
                break
        else:
            raise ValueError('Unable to find <21 Day Production Schedule> in %r' % file_name)
        for i, row in enumerate(sheet.rows(start_row=1), start=1):
            sheet_data.append(tuple([c.strip() for c in row]))
    #
    print('%d lines in sheet' % (len(sheet_data), ))
    for i, row in enumerate(sheet_data, start=2):
        last_row = None
        if row == last_row:
            continue
        try:
            last_row = row
            order = AttrDict()
            # add order number and line id last, as this may be a multiline setup
            id_num = row[ORDER_NUM]
            print('  processing row %d, order %s' % (i, id_num), verbose=3)
            # order.user = row[EMAIL]
            order.dept = row[DEPT]
            order.item_id = oe_products[row[ITEM_CODE]]
            # order.desc= row[ITEM_DESC]
            order.confirmed = (False, 'fis')[row[CONFIRMED] == 'Y']
            order.ordered_qty = float(row[QTY].strip() or 0)
            order.schedule_date = fix_date(row[DATE], format='ymd')
            order.day = Weekday.from_abbr(row[DAY])
            order.coating = row[COATING]
            order.allergens = row[ALLERGENS]
            #
            line = row[PROD_LINE]
            line = ('0' + line)[-2:]
            lines = oe_production_lines[line]
            if len(lines) == 1:
                # simple case, just the one order step
                [line] = lines
                order.order_no = id_num
                order.line_id = line
                orders[id_num] = order
            else:
                # multiple steps: make a copy for each one
                total = len(lines)
                for i, line_step in enumerate(lines, start=1):
                    num_step = "%s-%d_%d" % (id_num, i, total)
                    order_step = order.copy()
                    order_step.order_no = num_step
                    order_step.line_id = line_step
                    orders[num_step] = order_step
        except Exception as exc:
            error('unable to process row %d: %r\n%r' % (i, row, exc))
            continue
    return orders

def split_steps(order):
    "return record for each step in line_id"
    if isinstance(order.line_id, (Many2One, bool)):
        # line_id is already set, or is False and cannot be set
        return {order.order_no: order}
    # order is an AttrDict, line_id is a two-character field
    orders = {}
    lines = oe_production_lines[order.line_id]
    if len(lines) == 1:
        # simple case, just the one order step
        [line] = lines
        order.line_id = line
        return {order.order_no: order}
    else:
        # multiple steps: make a copy for each one
        total = len(lines)
        for i, line_step in enumerate(lines, start=1):
            num_step = "%s-%d_%d" % (order.order_no, i, total)
            order_step = order.copy()
            order_step.order_no = num_step
            order_step.line_id = line_step
            orders[num_step] = order_step
    return orders


Main()
